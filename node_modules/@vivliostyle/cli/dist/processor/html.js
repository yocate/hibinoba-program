import { jsx as _jsx, jsxs as _jsxs } from "hastscript/jsx-runtime";
import jsdom, { ResourceLoader as BaseResourceLoader, JSDOM, } from '@vivliostyle/jsdom';
import chalk from 'chalk';
import * as cheerio from 'cheerio';
import DOMPurify from 'dompurify';
import { toHtml } from 'hast-util-to-html';
import fs from 'node:fs';
import { fileURLToPath, pathToFileURL } from 'node:url';
import prettier from 'prettier';
import upath from 'upath';
import { decodePublicationManifest } from '../output/webbook.js';
import { DetailError, assertPubManifestSchema, debug, isUrlString, logWarn, } from '../util.js';
const virtualConsole = new jsdom.VirtualConsole();
/* v8 ignore start */
virtualConsole.on('error', (message) => {
    debug('[JSDOM Console] error:', message);
});
virtualConsole.on('warn', (message) => {
    debug('[JSDOM Console] warn:', message);
});
virtualConsole.on('log', (message) => {
    debug('[JSDOM Console] log:', message);
});
virtualConsole.on('info', (message) => {
    debug('[JSDOM Console] info:', message);
});
virtualConsole.on('dir', (message) => {
    debug('[JSDOM Console] dir:', message);
});
virtualConsole.on('jsdomError', (error) => {
    // Most of CSS using Paged media will be failed to run CSS parser of JSDOM.
    // We just ignore it because we don't use CSS parse results.
    // https://github.com/jsdom/jsdom/blob/a39e0ec4ce9a8806692d986a7ed0cd565ec7498a/lib/jsdom/living/helpers/stylesheets.js#L33-L44
    // see also: https://github.com/jsdom/jsdom/issues/2005
    if (error.message === 'Could not parse CSS stylesheet') {
        return;
    }
    throw new DetailError('Error occurred when loading HTML', error.stack ?? error.message);
});
/* v8 ignore stop */
export const htmlPurify = DOMPurify(new JSDOM('').window);
export class ResourceLoader extends BaseResourceLoader {
    fetcherMap = new Map();
    fetch(url, options) {
        debug(`[JSDOM] Fetching resource: ${url}`);
        const fetcher = super.fetch(url, options);
        if (fetcher) {
            this.fetcherMap.set(url, fetcher);
        }
        return fetcher;
    }
}
export async function getJsdomFromUrlOrFile(src, resourceLoader) {
    const url = isUrlString(src) ? new URL(src) : pathToFileURL(src);
    let dom;
    if (url.protocol === 'http:' || url.protocol === 'https:') {
        dom = await JSDOM.fromURL(src, {
            virtualConsole,
            resources: resourceLoader,
        });
    }
    else if (url.protocol === 'file:') {
        if (resourceLoader) {
            const file = resourceLoader._readFile(fileURLToPath(url));
            resourceLoader.fetcherMap.set(url.href, file);
        }
        dom = await JSDOM.fromFile(fileURLToPath(url), {
            virtualConsole,
            resources: resourceLoader,
            contentType: 'text/html; charset=UTF-8',
        });
    }
    else {
        throw new Error(`Unsupported protocol: ${url.protocol}`);
    }
    return { dom };
}
export function getJsdomFromString(html) {
    const dom = new JSDOM(html, {
        virtualConsole,
    });
    return { dom };
}
export async function getStructuredSectionFromHtml(htmlPath, href) {
    const { dom } = await getJsdomFromUrlOrFile(htmlPath);
    const { document } = dom.window;
    const allHeadings = [...document.querySelectorAll('h1, h2, h3, h4, h5, h6')]
        .filter((el) => {
        // Exclude headings contained by blockquote
        // TODO: Make customizable
        return !el.matches('blockquote *');
    })
        .sort((a, b) => {
        const position = a.compareDocumentPosition(b);
        return position & 2 /* DOCUMENT_POSITION_PRECEDING */
            ? 1
            : position & 4 /* DOCUMENT_POSITION_FOLLOWING */
                ? -1
                : 0;
    });
    function traverse(headers) {
        if (headers.length === 0) {
            return [];
        }
        const [head, ...tail] = headers;
        const section = head.parentElement;
        const id = head.id || section.id;
        const level = Number(head.tagName.slice(1));
        let i = tail.findIndex((s) => Number(s.tagName.slice(1)) <= level);
        i = i === -1 ? tail.length : i;
        return [
            {
                headingHtml: htmlPurify.sanitize(head.innerHTML),
                headingText: head.textContent?.trim().replace(/\s+/g, ' ') || '',
                level,
                ...(href && id && { href: `${href}#${encodeURIComponent(id)}` }),
                ...(id && { id }),
                children: traverse(tail.slice(0, i)),
            },
            ...traverse(tail.slice(i)),
        ];
    }
    return traverse(allHeadings);
}
const getTocHtmlStyle = ({ pageBreakBefore, pageCounterReset, }) => {
    if (!pageBreakBefore && typeof pageCounterReset !== 'number') {
        return null;
    }
    return /* css */ `
${pageBreakBefore
        ? `:root {
  break-before: ${pageBreakBefore};
}`
        : ''}
${typeof pageCounterReset === 'number'
        ? `@page :nth(1) {
  counter-reset: page ${Math.floor(pageCounterReset - 1)};
}`
        : ''}
`;
};
export const defaultTocTransform = {
    transformDocumentList: (nodeList) => (propsList) => {
        return (_jsx("ol", { children: nodeList
                .map((a, i) => [a, propsList[i]])
                .flatMap(([{ href, title, sections }, { children, ...otherProps }]) => {
                // don't display the document title if it has only one top-level H1 heading
                if (sections?.length === 1 && sections[0].level === 1) {
                    return [children].flat().flatMap((e) => {
                        if (e.type === 'element' && e.tagName === 'ol') {
                            return e.children;
                        }
                        return e;
                    });
                }
                return (_jsxs("li", { ...otherProps, children: [_jsx("a", { href, children: title }), children] }));
            }) }));
    },
    transformSectionList: (nodeList) => (propsList) => {
        return (_jsx("ol", { children: nodeList
                .map((a, i) => [a, propsList[i]])
                .map(([{ headingHtml, href, level }, { children, ...otherProps }]) => {
                const headingContent = {
                    type: 'raw',
                    value: headingHtml,
                };
                return (_jsxs("li", { ...otherProps, "data-section-level": level, children: [href ? (_jsx("a", { href, children: headingContent })) : (_jsx("span", { children: headingContent })), children] }));
            }) }));
    },
};
export function generateDefaultTocHtml({ language, title, }) {
    const toc = (_jsxs("html", { lang: language, children: [_jsxs("head", { children: [_jsx("meta", { charset: "utf-8" }), _jsx("title", { children: title || '' }), _jsx("style", { "data-vv-style": true })] }), _jsxs("body", { children: [_jsx("h1", { children: title || '' }), _jsx("nav", { id: "toc", role: "doc-toc" })] })] }));
    return toHtml(toc);
}
export async function generateTocListSection({ entries, distDir, sectionDepth, transform = {}, }) {
    const { transformDocumentList = defaultTocTransform.transformDocumentList, transformSectionList = defaultTocTransform.transformSectionList, } = transform;
    const structure = await Promise.all(entries.map(async (entry) => {
        const href = encodeURI(upath.relative(distDir, entry.target));
        const sections = sectionDepth >= 1
            ? await getStructuredSectionFromHtml(entry.target, href)
            : [];
        return {
            title: entry.title || upath.basename(entry.target, '.html'),
            href: encodeURI(upath.relative(distDir, entry.target)),
            sections,
            children: [], // TODO
        };
    }));
    const docToc = transformDocumentList(structure)(structure.map((doc) => {
        function renderSectionList(sections) {
            const nodeList = sections.flatMap((section) => {
                if (section.level > sectionDepth) {
                    return [];
                }
                return section;
            });
            if (nodeList.length === 0) {
                return [];
            }
            return transformSectionList(nodeList)(nodeList.map((node) => ({
                children: [renderSectionList(node.children || [])].flat(),
            })));
        }
        return {
            children: [renderSectionList(doc.sections || [])].flat(),
        };
    }));
    return toHtml(docToc, { allowDangerousHtml: true });
}
export async function processTocHtml(html, { manifestPath, tocTitle, styleOptions = {}, entries, distDir, sectionDepth, transform, }) {
    const { dom } = getJsdomFromString(html);
    const { document } = dom.window;
    if (!document.querySelector('link[rel="publication"][type="application/ld+json"]')) {
        const l = document.createElement('link');
        l.setAttribute('rel', 'publication');
        l.setAttribute('type', 'application/ld+json');
        l.setAttribute('href', encodeURI(upath.relative(distDir, manifestPath)));
        document.head.appendChild(l);
    }
    const style = document.querySelector('style[data-vv-style]');
    if (style) {
        const textContent = getTocHtmlStyle(styleOptions);
        if (textContent) {
            style.textContent = textContent;
        }
        else {
            style.remove();
        }
    }
    const nav = document.querySelector('nav, [role="doc-toc"]');
    if (nav && !nav.hasChildNodes()) {
        const h2 = document.createElement('h2');
        h2.textContent = tocTitle;
        nav.appendChild(h2);
        nav.innerHTML += await generateTocListSection({
            entries,
            distDir,
            sectionDepth,
            transform,
        });
    }
    return await prettier.format(dom.serialize(), { parser: 'html' });
}
const getCoverHtmlStyle = ({ pageBreakBefore, }) => /* css */ `
${pageBreakBefore
    ? `:root {
  break-before: ${pageBreakBefore};
}`
    : ''}
body {
  margin: 0;
}
[role="doc-cover"] {
  display: block;
  width: 100vw;
  height: 100vh;
  object-fit: contain;
}
@page {
  margin: 0;
}
`;
export function generateDefaultCoverHtml({ language, title, }) {
    const toc = (_jsxs("html", { lang: language, children: [_jsxs("head", { children: [_jsx("meta", { charset: "utf-8" }), _jsx("title", { children: title || '' }), _jsx("style", { "data-vv-style": true })] }), _jsx("body", { children: _jsx("section", { role: "region", "aria-label": "Cover", children: _jsx("img", { role: "doc-cover" }) }) })] }));
    return toHtml(toc);
}
export async function processCoverHtml(html, { imageSrc, imageAlt, styleOptions = {}, }) {
    const { dom } = getJsdomFromString(html);
    const { document } = dom.window;
    const style = document.querySelector('style[data-vv-style]');
    if (style) {
        const textContent = getCoverHtmlStyle(styleOptions);
        if (textContent) {
            style.textContent = textContent;
        }
        else {
            style.remove();
        }
    }
    const cover = document.querySelector('img[role="doc-cover"]');
    if (cover && !cover.hasAttribute('src')) {
        cover.setAttribute('src', encodeURI(imageSrc));
    }
    if (cover && !cover.hasAttribute('alt')) {
        cover.setAttribute('alt', imageAlt);
    }
    return await prettier.format(dom.serialize(), { parser: 'html' });
}
export function processManuscriptHtml(html, { title, style, contentType, language, }) {
    const $ = cheerio.load(html, {
        xmlMode: contentType === 'application/xhtml+xml',
    });
    if (title) {
        if (!$('title').html()) {
            $('head').append($('<title></title>'));
        }
        $('title').text(title);
    }
    for (const s of style ?? []) {
        $('head').append(`<link rel="stylesheet" type="text/css" />`);
        $('head > *:last-child').attr('href', encodeURI(s));
    }
    if (language) {
        if (contentType === 'application/xhtml+xml') {
            if (!$('html').attr('xml:lang')) {
                $('html').attr('lang', language);
                $('html').attr('xml:lang', language);
            }
        }
        else {
            if (!$('html').attr('lang')) {
                $('html').attr('lang', language);
            }
        }
    }
    let processed = $.html();
    return processed;
}
export function isTocHtml(filepath) {
    try {
        const $ = cheerio.load(fs.readFileSync(filepath, 'utf8'));
        return ($('[role="doc-toc"], [role="directory"], nav, .toc, #toc').length > 0);
    }
    catch (err) {
        // seems not to be a html file
        return false;
    }
}
export function isCovertHtml(filepath) {
    try {
        const $ = cheerio.load(fs.readFileSync(filepath, 'utf8'));
        return $('[role="doc-cover"]').length > 0;
    }
    catch (err) {
        // seems not to be a html file
        return false;
    }
}
export async function fetchLinkedPublicationManifest({ dom, resourceLoader, baseUrl, }) {
    const { document } = dom.window;
    const linkEl = document.querySelector('link[href][rel="publication"]');
    if (!linkEl) {
        return null;
    }
    const href = linkEl.getAttribute('href').trim();
    let manifest;
    let manifestUrl = baseUrl;
    if (href.startsWith('#')) {
        const scriptEl = document.getElementById(href.slice(1));
        if (scriptEl?.getAttribute('type') !== 'application/ld+json') {
            return null;
        }
        debug(`Found embedded publication manifest: ${href}`);
        try {
            manifest = JSON.parse(scriptEl.innerHTML);
        }
        catch (error) {
            const thrownError = error;
            throw new DetailError('Failed to parse manifest data', typeof thrownError.stack ?? thrownError.message);
        }
    }
    else {
        debug(`Found linked publication manifest: ${href}`);
        const url = new URL(href, baseUrl);
        manifestUrl = url.href;
        const buffer = await resourceLoader.fetch(url.href);
        if (!buffer) {
            throw new Error(`Failed to fetch manifest JSON file: ${url.href}`);
        }
        const manifestJson = buffer.toString();
        try {
            manifest = JSON.parse(manifestJson);
        }
        catch (error) {
            const thrownError = error;
            throw new DetailError('Failed to parse manifest data', typeof thrownError.stack ?? thrownError.message);
        }
    }
    try {
        assertPubManifestSchema(manifest);
    }
    catch (error) {
        logWarn(`${chalk.yellowBright('Publication manifest validation failed. Processing continues, but some problems may occur.')}\n${error}`);
    }
    return {
        manifest: decodePublicationManifest(manifest),
        manifestUrl,
    };
}
export function parseTocDocument(dom) {
    const { document } = dom.window;
    const docTocEl = document.querySelectorAll('[role="doc-toc"]');
    if (docTocEl.length === 0) {
        return null;
    }
    const tocRoot = docTocEl.item(0);
    const parseTocItem = (element) => {
        if (element.tagName !== 'LI') {
            return null;
        }
        const label = element.children.item(0);
        const ol = element.children.item(1);
        if (!label || (label.tagName !== 'A' && label.tagName !== 'SPAN')) {
            return null;
        }
        if (!ol || ol.tagName !== 'OL') {
            return { element: element, label: label };
        }
        const children = Array.from(ol.children).reduce((acc, val) => {
            if (!acc) {
                return acc;
            }
            const res = parseTocItem(val);
            return res && [...acc, res];
        }, []);
        return (children && {
            element: element,
            label: label,
            children,
        });
    };
    let heading;
    for (let child of Array.from(tocRoot.children)) {
        if (child.tagName === 'OL') {
            const children = Array.from(child.children).reduce((acc, val) => {
                if (!acc) {
                    return acc;
                }
                const res = parseTocItem(val);
                return res && [...acc, res];
            }, []);
            return children && { element: tocRoot, heading, children };
        }
        else if (['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HGROUP'].includes(child.tagName)) {
            heading = child;
        }
        else {
            return null;
        }
    }
    return null;
}
export function parsePageListDocument(dom) {
    const { document } = dom.window;
    const docPageListEl = document.querySelectorAll('[role="doc-pagelist"]');
    if (docPageListEl.length === 0) {
        return null;
    }
    const pageListRoot = docPageListEl.item(0);
    let heading;
    for (let child of Array.from(pageListRoot.children)) {
        if (child.tagName === 'OL') {
            const children = Array.from(child.children).reduce((acc, element) => {
                return (acc &&
                    (element.tagName === 'LI'
                        ? [...acc, { element: element }]
                        : null));
            }, []);
            return (children && { element: pageListRoot, heading, children });
        }
        else if (['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HGROUP'].includes(child.tagName)) {
            heading = child;
        }
        else {
            return null;
        }
    }
    return null;
}
//# sourceMappingURL=html.js.map