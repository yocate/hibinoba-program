import jsdom, { ResourceLoader as BaseResourceLoader, JSDOM } from '@vivliostyle/jsdom';
import DOMPurify from 'dompurify';
import type { ManuscriptEntry } from '../input/config.js';
import type { StructuredDocument, StructuredDocumentSection } from '../input/schema.js';
import type { PublicationManifest } from '../schema/publication.schema.js';
export declare const htmlPurify: DOMPurify.DOMPurifyI;
export declare class ResourceLoader extends BaseResourceLoader {
    fetcherMap: Map<string, jsdom.AbortablePromise<Buffer>>;
    fetch(url: string, options?: jsdom.FetchOptions): jsdom.AbortablePromise<Buffer> | null;
}
export declare function getJsdomFromUrlOrFile(src: string, resourceLoader?: ResourceLoader): Promise<{
    dom: JSDOM;
}>;
export declare function getJsdomFromString(html: string): {
    dom: JSDOM;
};
export declare function getStructuredSectionFromHtml(htmlPath: string, href?: string): Promise<StructuredDocumentSection[]>;
declare const getTocHtmlStyle: ({ pageBreakBefore, pageCounterReset, }: {
    pageBreakBefore?: "recto" | "verso" | "left" | "right";
    pageCounterReset?: number;
}) => string | null;
type HastElement = import('hast').ElementContent | import('hast').Root;
export declare const defaultTocTransform: {
    transformDocumentList: (nodeList: StructuredDocument[]) => (propsList: {
        children: HastElement | HastElement[];
    }[]) => HastElement;
    transformSectionList: (nodeList: StructuredDocumentSection[]) => (propsList: {
        children: HastElement | HastElement[];
    }[]) => HastElement;
};
export declare function generateDefaultTocHtml({ language, title, }: {
    language?: string;
    title?: string;
}): string;
export declare function generateTocListSection({ entries, distDir, sectionDepth, transform, }: {
    entries: Pick<ManuscriptEntry, 'target' | 'title'>[];
    distDir: string;
    sectionDepth: number;
    transform?: Partial<typeof defaultTocTransform>;
}): Promise<string>;
export declare function processTocHtml(html: string, { manifestPath, tocTitle, styleOptions, entries, distDir, sectionDepth, transform, }: Parameters<typeof generateTocListSection>[0] & {
    manifestPath: string;
    tocTitle: string;
    styleOptions?: Parameters<typeof getTocHtmlStyle>[0];
}): Promise<string>;
declare const getCoverHtmlStyle: ({ pageBreakBefore, }: {
    pageBreakBefore?: "recto" | "verso" | "left" | "right";
}) => string;
export declare function generateDefaultCoverHtml({ language, title, }: {
    language?: string;
    title?: string;
}): string;
export declare function processCoverHtml(html: string, { imageSrc, imageAlt, styleOptions, }: {
    imageSrc: string;
    imageAlt: string;
    styleOptions?: Parameters<typeof getCoverHtmlStyle>[0];
}): Promise<string>;
export declare function processManuscriptHtml(html: string, { title, style, contentType, language, }: {
    title?: string;
    style?: string[];
    contentType?: 'text/html' | 'application/xhtml+xml';
    language?: string | null;
}): string;
export declare function isTocHtml(filepath: string): boolean;
export declare function isCovertHtml(filepath: string): boolean;
export declare function fetchLinkedPublicationManifest({ dom, resourceLoader, baseUrl, }: {
    dom: JSDOM;
    resourceLoader: ResourceLoader;
    baseUrl: string;
}): Promise<{
    manifest: PublicationManifest;
    manifestUrl: string;
} | null>;
export type TocResourceTreeItem = {
    element: HTMLElement;
    label: HTMLElement;
    children?: TocResourceTreeItem[];
};
export type TocResourceTreeRoot = {
    element: HTMLElement;
    heading?: HTMLElement;
    children: TocResourceTreeItem[];
};
export declare function parseTocDocument(dom: JSDOM): TocResourceTreeRoot | null;
export type PageListResourceTreeItem = {
    element: HTMLElement;
};
export type PageListResourceTreeRoot = {
    element: HTMLElement;
    heading?: HTMLElement;
    children: PageListResourceTreeItem[];
};
export declare function parsePageListDocument(dom: JSDOM): PageListResourceTreeRoot | null;
export {};
//# sourceMappingURL=html.d.ts.map