import { Metadata, StringifyMarkdownOptions } from '@vivliostyle/vfm';
import { Processor } from 'unified';
import { InputFormat, ManuscriptMediaType } from '../input/input-types.js';
import { OutputFormat } from '../output/output-types.js';
import { PageSize } from '../server.js';
import { BrowserType, StructuredDocument, StructuredDocumentSection, ThemeObject, VivliostyleConfigEntry } from './schema.js';
export type ParsedTheme = UriTheme | FileTheme | PackageTheme;
export interface UriTheme {
    type: 'uri';
    name: string;
    location: string;
}
export interface FileTheme {
    type: 'file';
    name: string;
    source: string;
    location: string;
}
export interface PackageTheme {
    type: 'package';
    name: string;
    specifier: string;
    location: string;
    importPath?: string | string[];
}
export interface ManuscriptEntry {
    type: ManuscriptMediaType;
    title?: string;
    themes: ParsedTheme[];
    source: string;
    template?: undefined;
    target: string;
    rel?: string | string[];
}
export interface ContentsEntry {
    rel: 'contents';
    title?: string;
    themes: ParsedTheme[];
    source?: undefined;
    template?: {
        source: string;
        type: ManuscriptMediaType;
    };
    target: string;
    tocTitle: string;
    sectionDepth: number;
    transform: {
        transformDocumentList: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    };
    pageBreakBefore?: 'left' | 'right' | 'recto' | 'verso';
    pageCounterReset?: number;
}
export interface CoverEntry {
    rel: 'cover';
    title?: string;
    themes: ParsedTheme[];
    source?: undefined;
    template?: {
        source: string;
        type: ManuscriptMediaType;
    };
    target: string;
    coverImageSrc: string;
    coverImageAlt: string;
    pageBreakBefore?: 'left' | 'right' | 'recto' | 'verso';
}
export type ParsedEntry = ManuscriptEntry | ContentsEntry | CoverEntry;
export interface CliFlags {
    input?: string;
    configPath?: string;
    targets?: Pick<OutputFormat, 'path' | 'format'>[];
    theme?: string;
    size?: string;
    cropMarks?: boolean;
    bleed?: string;
    cropOffset?: string;
    css?: string;
    style?: string;
    userStyle?: string;
    singleDoc?: boolean;
    quick?: boolean;
    pressReady?: boolean;
    title?: string;
    author?: string;
    language?: string;
    /** @deprecated */ verbose?: boolean;
    timeout?: number;
    renderMode?: 'local' | 'docker';
    preflight?: 'press-ready' | 'press-ready-local';
    preflightOption?: string[];
    sandbox?: boolean;
    executableBrowser?: string;
    image?: string;
    http?: boolean;
    viewer?: string;
    viewerParam?: string;
    browser?: 'chromium' | 'firefox' | 'webkit';
    proxyServer?: string;
    proxyBypass?: string;
    proxyUser?: string;
    proxyPass?: string;
    readingProgression?: 'ltr' | 'rtl';
    logLevel?: 'silent' | 'info' | 'verbose' | 'debug';
    ignoreHttpsErrors?: boolean;
    /** @deprecated */ executableChromium?: string;
}
export interface WebPublicationManifestConfig {
    manifestPath: string;
    needToGenerateManifest?: boolean;
}
export interface EpubManifestConfig {
    epubOpfPath: string;
}
export interface WebbookEntryConfig {
    webbookEntryUrl: string;
}
export type ManifestConfig = XOR<[
    WebPublicationManifestConfig,
    WebbookEntryConfig,
    EpubManifestConfig
]>;
export type DocumentProcessorFactory = (options: StringifyMarkdownOptions, metadata: Metadata) => Processor;
export type MergedConfig = {
    entryContextDir: string;
    workspaceDir: string;
    themesDir: string;
    entries: ParsedEntry[];
    input: InputFormat;
    outputs: OutputFormat[];
    themeIndexes: Set<ParsedTheme>;
    rootThemes: ParsedTheme[];
    copyAsset: {
        includes: string[];
        excludes: string[];
        fileExtensions: string[];
    };
    exportAliases: {
        source: string;
        target: string;
    }[];
    size: PageSize | undefined;
    cropMarks: boolean;
    bleed: string | undefined;
    cropOffset: string | undefined;
    css: string | undefined;
    customStyle: string | undefined;
    customUserStyle: string | undefined;
    singleDoc: boolean;
    quick: boolean;
    title: string | undefined;
    author: string | undefined;
    language: string | undefined;
    readingProgression: 'ltr' | 'rtl' | undefined;
    documentProcessorFactory: DocumentProcessorFactory;
    vfmOptions: {
        hardLineBreaks: boolean;
        disableFormatHtml: boolean;
    };
    cover: {
        src: string;
        name: string;
        htmlPath: string | undefined;
    } | undefined;
    timeout: number;
    sandbox: boolean;
    executableBrowser: string;
    browserType: BrowserType;
    proxy: {
        server: string;
        bypass: string | undefined;
        username: string | undefined;
        password: string | undefined;
    } | undefined;
    image: string;
    httpServer: boolean;
    viewer: string | undefined;
    viewerParam: string | undefined;
    logLevel: 'silent' | 'info' | 'verbose' | 'debug';
    ignoreHttpsErrors: boolean;
} & ManifestConfig;
export declare function validateTimeoutFlag(val: string): number;
export declare function contextResolve(context: string, loc: string | undefined): string | undefined;
export declare function parseTheme({ theme, context, workspaceDir, themesDir, }: {
    theme: string | ThemeObject;
    context: string;
    workspaceDir: string;
    themesDir: string;
}): ParsedTheme;
export declare function collectVivliostyleConfig<T extends CliFlags>(cliFlags: T): Promise<{
    cliFlags: T;
} & ({
    vivliostyleConfig: VivliostyleConfigEntry[];
    vivliostyleConfigPath: string;
} | {
    vivliostyleConfig?: undefined;
    vivliostyleConfigPath?: undefined;
})>;
export declare function mergeConfig<T extends CliFlags>(cliFlags: T, config: VivliostyleConfigEntry | undefined, context: string, prevConfig?: MergedConfig): Promise<MergedConfig>;
//# sourceMappingURL=config.d.ts.map