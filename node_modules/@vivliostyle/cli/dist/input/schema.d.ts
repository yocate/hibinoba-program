import { Metadata, StringifyMarkdownOptions } from '@vivliostyle/vfm';
import { type Processor } from 'unified';
import * as v from 'valibot';
/**
 * @see https://github.com/vivliostyle/vivliostyle-cli/blob/main/docs/config.md
 */
export type StructuredDocument = {
    title: string;
    href: string;
    children: StructuredDocument[];
    sections?: StructuredDocumentSection[];
};
/** @hidden */
export declare const StructuredDocument: v.GenericSchema<StructuredDocument>;
/**
 * @see https://github.com/vivliostyle/vivliostyle-cli/blob/main/docs/config.md
 */
export type StructuredDocumentSection = {
    headingHtml: string;
    headingText: string;
    level: number;
    children: StructuredDocumentSection[];
    href?: string;
    id?: string;
};
/** @hidden */
export declare const StructuredDocumentSection: v.GenericSchema<StructuredDocumentSection>;
export declare const ValidString: v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
export declare const ThemeObject: v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
    readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
}, undefined>, "_types" | "_run" | "entries"> & {
    readonly entries: {
        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
    };
    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
        specifier: string;
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
    readonly _types?: {
        readonly input: {
            specifier: string;
        };
        readonly output: {
            specifier: string;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
    } | undefined;
}, Omit<v.ObjectSchema<{
    readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
}, undefined>, "_types" | "_run" | "entries"> & {
    readonly entries: {
        readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
    };
    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
        import?: string | string[] | undefined;
    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
    readonly _types?: {
        readonly input: {
            import?: string | string[] | undefined;
        };
        readonly output: {
            import?: string | string[] | undefined;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
    } | undefined;
}], undefined>, v.TitleAction<{
    specifier: string;
} & {
    import?: string | string[] | undefined;
}, "ThemeObject">]>;
export type ThemeObject = v.InferInput<typeof ThemeObject>;
export declare const ThemeSpecifier: v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
    readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
}, undefined>, "_types" | "_run" | "entries"> & {
    readonly entries: {
        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
    };
    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
        specifier: string;
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
    readonly _types?: {
        readonly input: {
            specifier: string;
        };
        readonly output: {
            specifier: string;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
    } | undefined;
}, Omit<v.ObjectSchema<{
    readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
}, undefined>, "_types" | "_run" | "entries"> & {
    readonly entries: {
        readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
    };
    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
        import?: string | string[] | undefined;
    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
    readonly _types?: {
        readonly input: {
            import?: string | string[] | undefined;
        };
        readonly output: {
            import?: string | string[] | undefined;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
    } | undefined;
}], undefined>, v.TitleAction<{
    specifier: string;
} & {
    import?: string | string[] | undefined;
}, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
    readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
}, undefined>, "_types" | "_run" | "entries"> & {
    readonly entries: {
        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
    };
    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
        specifier: string;
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
    readonly _types?: {
        readonly input: {
            specifier: string;
        };
        readonly output: {
            specifier: string;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
    } | undefined;
}, Omit<v.ObjectSchema<{
    readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
}, undefined>, "_types" | "_run" | "entries"> & {
    readonly entries: {
        readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
    };
    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
        import?: string | string[] | undefined;
    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
    readonly _types?: {
        readonly input: {
            import?: string | string[] | undefined;
        };
        readonly output: {
            import?: string | string[] | undefined;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
    } | undefined;
}], undefined>, v.TitleAction<{
    specifier: string;
} & {
    import?: string | string[] | undefined;
}, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>;
export type ThemeSpecifier = v.InferInput<typeof ThemeSpecifier>;
export declare const ArticleEntryObject: v.SchemaWithPipe<[Omit<v.ObjectSchema<{
    readonly path: v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
    readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            import?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
        readonly _types?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            import?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
        readonly _types?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
    readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
}, undefined>, "_types" | "_run" | "entries"> & {
    readonly entries: {
        readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
    };
    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>>;
    readonly _types?: {
        readonly input: {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        };
        readonly output: {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>;
    } | undefined;
}, v.TitleAction<{
    path: string;
    output?: string | undefined;
    title?: string | undefined;
    theme?: string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }))[] | undefined;
    encodingFormat?: string | undefined;
    rel?: string | string[] | undefined;
}, "ArticleEntryObject">]>;
export type ArticleEntryObject = v.InferInput<typeof ArticleEntryObject>;
export declare const ContentsEntryObject: v.SchemaWithPipe<[v.ObjectSchema<{
    readonly rel: v.LiteralSchema<"contents", undefined>;
    readonly path: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            import?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
        readonly _types?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            import?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
        readonly _types?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
    readonly pageBreakBefore: v.SchemaWithPipe<[v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, never>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, "\n        Specify the page break position before this document.\n        It is useful when you want to specify which side a first page of the document should be placed on a two-page spread.\n      ">]>;
    readonly pageCounterReset: v.SchemaWithPipe<[v.OptionalSchema<v.SchemaWithPipe<[v.NumberSchema<undefined>, v.SafeIntegerAction<number, undefined>]>, never>, v.DescriptionAction<number | undefined, "\n        Reset the starting page number of this document by the specified integer.\n        It is useful when you want to control page numbers when including a page.\n      ">]>;
}, undefined>, v.TitleAction<{
    rel: "contents";
    output?: string | undefined;
    title?: string | undefined;
    theme?: string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }))[] | undefined;
    path?: string | undefined;
    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    pageCounterReset?: number | undefined;
}, "ContentsEntryObject">]>;
export type ContentsEntryObject = v.InferInput<typeof ContentsEntryObject>;
export declare const CoverEntryObject: v.SchemaWithPipe<[v.ObjectSchema<{
    readonly rel: v.LiteralSchema<"cover", undefined>;
    readonly path: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            import?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
        readonly _types?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            import?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
        readonly _types?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
    readonly imageSrc: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly imageAlt: v.OptionalSchema<v.StringSchema<undefined>, never>;
    readonly pageBreakBefore: v.SchemaWithPipe<[v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, never>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, "\n      Specify the page break position before this document.\n      It is useful when you want to specify which side a first page of the document should be placed on a two-page spread.\n    ">]>;
}, undefined>, v.TitleAction<{
    rel: "cover";
    output?: string | undefined;
    title?: string | undefined;
    theme?: string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }))[] | undefined;
    path?: string | undefined;
    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    imageSrc?: string | undefined;
    imageAlt?: string | undefined;
}, "CoverEntryObject">]>;
export type CoverEntryObject = v.InferInput<typeof CoverEntryObject>;
export declare const EntryObject: v.UnionSchema<[v.SchemaWithPipe<[v.ObjectSchema<{
    readonly rel: v.LiteralSchema<"contents", undefined>;
    readonly path: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            import?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
        readonly _types?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            import?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
        readonly _types?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
    readonly pageBreakBefore: v.SchemaWithPipe<[v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, never>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, "\n        Specify the page break position before this document.\n        It is useful when you want to specify which side a first page of the document should be placed on a two-page spread.\n      ">]>;
    readonly pageCounterReset: v.SchemaWithPipe<[v.OptionalSchema<v.SchemaWithPipe<[v.NumberSchema<undefined>, v.SafeIntegerAction<number, undefined>]>, never>, v.DescriptionAction<number | undefined, "\n        Reset the starting page number of this document by the specified integer.\n        It is useful when you want to control page numbers when including a page.\n      ">]>;
}, undefined>, v.TitleAction<{
    rel: "contents";
    output?: string | undefined;
    title?: string | undefined;
    theme?: string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }))[] | undefined;
    path?: string | undefined;
    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    pageCounterReset?: number | undefined;
}, "ContentsEntryObject">]>, v.SchemaWithPipe<[v.ObjectSchema<{
    readonly rel: v.LiteralSchema<"cover", undefined>;
    readonly path: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            import?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
        readonly _types?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            import?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
        readonly _types?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
    readonly imageSrc: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly imageAlt: v.OptionalSchema<v.StringSchema<undefined>, never>;
    readonly pageBreakBefore: v.SchemaWithPipe<[v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, never>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, "\n      Specify the page break position before this document.\n      It is useful when you want to specify which side a first page of the document should be placed on a two-page spread.\n    ">]>;
}, undefined>, v.TitleAction<{
    rel: "cover";
    output?: string | undefined;
    title?: string | undefined;
    theme?: string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }))[] | undefined;
    path?: string | undefined;
    pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
    imageSrc?: string | undefined;
    imageAlt?: string | undefined;
}, "CoverEntryObject">]>, v.SchemaWithPipe<[Omit<v.ObjectSchema<{
    readonly path: v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
    readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            import?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
        readonly _types?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            import?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
        readonly _types?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
    readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
    readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
}, undefined>, "_types" | "_run" | "entries"> & {
    readonly entries: {
        readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
    };
    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>>;
    readonly _types?: {
        readonly input: {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        };
        readonly output: {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>;
    } | undefined;
}, v.TitleAction<{
    path: string;
    output?: string | undefined;
    title?: string | undefined;
    theme?: string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }))[] | undefined;
    encodingFormat?: string | undefined;
    rel?: string | string[] | undefined;
}, "ArticleEntryObject">]>], undefined>;
export type EntryObject = v.InferInput<typeof EntryObject>;
export declare const OutputObject: v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
    readonly path: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>;
}, undefined>, "_types" | "_run" | "entries"> & {
    readonly entries: {
        readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>, "Missing required field: path">;
    };
    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
        path: string;
    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
    readonly _types?: {
        readonly input: {
            path: string;
        };
        readonly output: {
            path: string;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
    } | undefined;
}, Omit<v.ObjectSchema<{
    readonly format: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>;
    readonly renderMode: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>;
    readonly preflight: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>;
    readonly preflightOption: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>;
}, undefined>, "_types" | "_run" | "entries"> & {
    readonly entries: {
        readonly format: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>, never>;
        readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>, never>;
        readonly preflight: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>, never>;
        readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>, never>;
    };
    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
    readonly _types?: {
        readonly input: {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        };
        readonly output: {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
    } | undefined;
}], undefined>, v.TitleAction<{
    path: string;
} & {
    format?: string | undefined;
    renderMode?: "local" | "docker" | undefined;
    preflight?: "press-ready" | "press-ready-local" | undefined;
    preflightOption?: string[] | undefined;
}, "OutputObject">]>;
export type OutputObject = v.InferInput<typeof OutputObject>;
export declare const VfmReplaceRule: v.LooseObjectSchema<{
    readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
    readonly match: v.SchemaWithPipe<[v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string, (result: RegExpMatchArray, h: any) => Object | string, v.BaseIssue<unknown>>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
        readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
    }>]>;
}, undefined>;
export type VfmReplaceRule = v.InferInput<typeof VfmReplaceRule>;
export declare const BrowserType: v.UnionSchema<[v.LiteralSchema<"chromium", undefined>, v.LiteralSchema<"firefox", undefined>, v.LiteralSchema<"webkit", undefined>], undefined>;
export type BrowserType = v.InferInput<typeof BrowserType>;
export declare const VivliostyleConfigEntry: v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
    readonly entry: v.SchemaWithPipe<[v.UnionSchema<[v.SchemaWithPipe<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<[v.ObjectSchema<{
        readonly rel: v.LiteralSchema<"contents", undefined>;
        readonly path: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        readonly pageBreakBefore: v.SchemaWithPipe<[v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, never>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, "\n        Specify the page break position before this document.\n        It is useful when you want to specify which side a first page of the document should be placed on a two-page spread.\n      ">]>;
        readonly pageCounterReset: v.SchemaWithPipe<[v.OptionalSchema<v.SchemaWithPipe<[v.NumberSchema<undefined>, v.SafeIntegerAction<number, undefined>]>, never>, v.DescriptionAction<number | undefined, "\n        Reset the starting page number of this document by the specified integer.\n        It is useful when you want to control page numbers when including a page.\n      ">]>;
    }, undefined>, v.TitleAction<{
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    }, "ContentsEntryObject">]>, v.SchemaWithPipe<[v.ObjectSchema<{
        readonly rel: v.LiteralSchema<"cover", undefined>;
        readonly path: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        readonly imageSrc: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly imageAlt: v.OptionalSchema<v.StringSchema<undefined>, never>;
        readonly pageBreakBefore: v.SchemaWithPipe<[v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, never>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, "\n      Specify the page break position before this document.\n      It is useful when you want to specify which side a first page of the document should be placed on a two-page spread.\n    ">]>;
    }, undefined>, v.TitleAction<{
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    }, "CoverEntryObject">]>, v.SchemaWithPipe<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>>;
        readonly _types?: {
            readonly input: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            };
            readonly output: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>;
        } | undefined;
    }, v.TitleAction<{
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    }, "ArticleEntryObject">]>], undefined>], undefined>, undefined>, v.MinLengthAction<(string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | {
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    })[], 1, "At least one entry is required">]>, v.SchemaWithPipe<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>>;
        readonly _types?: {
            readonly input: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            };
            readonly output: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>;
        } | undefined;
    }, v.TitleAction<{
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    }, "ArticleEntryObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | (string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | {
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    })[], "Entry file(s) of document.">]>;
}, undefined>, "_types" | "_run" | "entries"> & {
    readonly entries: {
        readonly entry: v.NonOptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.SchemaWithPipe<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<[v.ObjectSchema<{
            readonly rel: v.LiteralSchema<"contents", undefined>;
            readonly path: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            readonly pageBreakBefore: v.SchemaWithPipe<[v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, never>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, "\n        Specify the page break position before this document.\n        It is useful when you want to specify which side a first page of the document should be placed on a two-page spread.\n      ">]>;
            readonly pageCounterReset: v.SchemaWithPipe<[v.OptionalSchema<v.SchemaWithPipe<[v.NumberSchema<undefined>, v.SafeIntegerAction<number, undefined>]>, never>, v.DescriptionAction<number | undefined, "\n        Reset the starting page number of this document by the specified integer.\n        It is useful when you want to control page numbers when including a page.\n      ">]>;
        }, undefined>, v.TitleAction<{
            rel: "contents";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        }, "ContentsEntryObject">]>, v.SchemaWithPipe<[v.ObjectSchema<{
            readonly rel: v.LiteralSchema<"cover", undefined>;
            readonly path: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            readonly imageSrc: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly imageAlt: v.OptionalSchema<v.StringSchema<undefined>, never>;
            readonly pageBreakBefore: v.SchemaWithPipe<[v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, never>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, "\n      Specify the page break position before this document.\n      It is useful when you want to specify which side a first page of the document should be placed on a two-page spread.\n    ">]>;
        }, undefined>, v.TitleAction<{
            rel: "cover";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
        }, "CoverEntryObject">]>, v.SchemaWithPipe<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
                readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
                readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
                readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly _types?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        import?: string | string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                    readonly _types?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string | string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly _types?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        import?: string | string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                    readonly _types?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string | string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
                readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
                readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>>;
            readonly _types?: {
                readonly input: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                };
                readonly output: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>;
            } | undefined;
        }, v.TitleAction<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        }, "ArticleEntryObject">]>], undefined>], undefined>, undefined>, v.MinLengthAction<(string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | {
            rel: "contents";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
        })[], 1, "At least one entry is required">]>, v.SchemaWithPipe<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
                readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
                readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
                readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly _types?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        import?: string | string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                    readonly _types?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string | string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly _types?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        import?: string | string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                    readonly _types?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string | string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
                readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
                readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>>;
            readonly _types?: {
                readonly input: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                };
                readonly output: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>;
            } | undefined;
        }, v.TitleAction<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        }, "ArticleEntryObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | {
            rel: "contents";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
        })[], "Entry file(s) of document.">]>, "Missing required field: entry">;
    };
    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
        entry: string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | {
            rel: "contents";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
        })[];
    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | {
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    })[], 1> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | {
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    })[], 1>>>;
    readonly _types?: {
        readonly input: {
            entry: string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | {
                rel: "contents";
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                path?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                path?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
            })[];
        };
        readonly output: {
            entry: string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | {
                rel: "contents";
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                path?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                path?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
            })[];
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | {
            rel: "contents";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
        })[], 1> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | {
            rel: "contents";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
        })[], 1>>;
    } | undefined;
}, Omit<v.ObjectSchema<{
    readonly title: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Title">]>;
    readonly author: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Author">]>;
    readonly theme: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            import?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
        readonly _types?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            import?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
        readonly _types?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }))[], "Theme package path(s) or URL(s) of css file.">]>;
    readonly entryContext: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Directory of referencing entry file(s).">]>;
    readonly output: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>, "Missing required field: path">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            path: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                path: string;
            };
            readonly output: {
                path: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly format: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>;
        readonly renderMode: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>;
        readonly preflight: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>;
        readonly preflightOption: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly format: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>, never>;
            readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>, never>;
            readonly preflight: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>, never>;
            readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
        readonly _types?: {
            readonly input: {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly output: {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }, "OutputObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>, "Missing required field: path">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            path: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                path: string;
            };
            readonly output: {
                path: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly format: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>;
        readonly renderMode: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>;
        readonly preflight: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>;
        readonly preflightOption: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly format: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>, never>;
            readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>, never>;
            readonly preflight: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>, never>;
            readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
        readonly _types?: {
            readonly input: {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly output: {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }, "OutputObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | ({
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }) | (string | ({
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }))[], "Options about outputs.">]>;
    readonly workspaceDir: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n            Specify the directory where the intermediate files (manuscript HTMLs, publication.json, etc.) are saved.\n            If not specified, theses files are saved in the same directory as the input file.\n          ">]>;
    /** @deprecated */
    readonly includeAssets: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.MetadataAction<string | string[], {
        readonly deprecated: true;
    }>, v.DescriptionAction<string | string[], "Use `copyAsset.includes` instead">]>;
    readonly copyAsset: v.SchemaWithPipe<[Omit<v.ObjectSchema<{
        readonly includes: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to include as asset files.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>;
        readonly excludes: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to exclude from the asset file.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>;
        readonly includeFileExtensions: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to include as an asset file. (default: `[png, jpg, jpeg, svg, gif, webp, apng, ttf, otf, woff, woff2]`)">]>;
        readonly excludeFileExtensions: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to exclude as an asset file.">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly includes: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to include as asset files.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>, never>;
            readonly excludes: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to exclude from the asset file.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>, never>;
            readonly includeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to include as an asset file. (default: `[png, jpg, jpeg, svg, gif, webp, apng, ttf, otf, woff, woff2]`)">]>, never>;
            readonly excludeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to exclude as an asset file.">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        readonly _types?: {
            readonly input: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            };
            readonly output: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>;
        } | undefined;
    }, v.DescriptionAction<{
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    }, "Options about asset files to be copied when exporting output.">]>;
    readonly size: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n            Output pdf size. (default: `letter`)\n            - preset: `A5`, `A4`, `A3`, `B5`, `B4`, `JIS-B5`, `JIS-B4`, `letter`, `legal`, `ledger`\n            - custom(comma separated): `182mm,257mm` or `8.5in,11in`\n          ">]>;
    readonly pressReady: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "\n            Make generated PDF compatible with press ready PDF/X-1a. (default: `false`)\n            This option is equivalent with `\"preflight\": \"press-ready\"`\n          ">]>;
    readonly language: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Language">]>;
    readonly readingProgression: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"ltr", undefined>, v.LiteralSchema<"rtl", undefined>], undefined>, v.DescriptionAction<"ltr" | "rtl", "Specify the reading progression of the document. This is typically determined automatically by the CSS writing-mode, so use this option only if you need to set it explicitly.">]>;
    readonly toc: v.SchemaWithPipe<[v.UnionSchema<[Omit<v.ObjectSchema<{
        readonly title: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the title of the generated ToC document.">]>;
        readonly htmlPath: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the location where the generated ToC document will be saved. (default: `index.html`)">]>;
        readonly sectionDepth: v.SchemaWithPipe<[v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, "Specify the depth of the section to be included in the ToC document. (default: `0`)">]>;
        readonly transformDocumentList: v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, (nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, {
            readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
            readonly typeReferences: readonly [v.GenericSchema<StructuredDocument, StructuredDocument, v.BaseIssue<unknown>>];
        }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, "Specify the transform function for the document list.">]>;
        readonly transformSectionList: v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, (nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, {
            readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
            readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection, StructuredDocumentSection, v.BaseIssue<unknown>>];
        }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, "Specify the transform function for the section list.">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the title of the generated ToC document.">]>, never>;
            readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the location where the generated ToC document will be saved. (default: `index.html`)">]>, never>;
            readonly sectionDepth: v.OptionalSchema<v.SchemaWithPipe<[v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, "Specify the depth of the section to be included in the ToC document. (default: `0`)">]>, never>;
            readonly transformDocumentList: v.OptionalSchema<v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, (nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocument, StructuredDocument, v.BaseIssue<unknown>>];
            }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, "Specify the transform function for the document list.">]>, never>;
            readonly transformSectionList: v.OptionalSchema<v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, (nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection, StructuredDocumentSection, v.BaseIssue<unknown>>];
            }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, "Specify the transform function for the section list.">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }, v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>>;
        readonly _types?: {
            readonly input: {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            };
            readonly output: {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            };
            readonly issue: v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>;
        } | undefined;
    }, v.BooleanSchema<undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean | {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    }, "Options about Table of Contents (ToC) documents.">]>;
    /** @deprecated */
    readonly tocTitle: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.MetadataAction<string, {
        readonly deprecated: true;
    }>, v.DescriptionAction<string, "Use `toc.title` instead">]>;
    readonly cover: v.SchemaWithPipe<[v.UnionSchema<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly src: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the cover image to be used for the cover page.">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly src: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the cover image to be used for the cover page.">]>, "Missing required field: src">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            src: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                src: string;
            };
            readonly output: {
                src: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly name: v.SchemaWithPipe<[v.StringSchema<undefined>, v.DescriptionAction<string, "Specify alternative text for the cover image.">]>;
        readonly htmlPath: v.SchemaWithPipe<[v.UnionSchema<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, "\n                      Specify the location where the generated cover document will be saved. (default: cover.html)\n                      If falsy value is set, the cover document won't be generated.\n                    ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly name: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.DescriptionAction<string, "Specify alternative text for the cover image.">]>, never>;
            readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, "\n                      Specify the location where the generated cover document will be saved. (default: cover.html)\n                      If falsy value is set, the cover document won't be generated.\n                    ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            htmlPath?: string | boolean | undefined;
            name?: string | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>>;
        readonly _types?: {
            readonly input: {
                htmlPath?: string | boolean | undefined;
                name?: string | undefined;
            };
            readonly output: {
                htmlPath?: string | boolean | undefined;
                name?: string | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>;
        } | undefined;
    }], undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | ({
        src: string;
    } & {
        htmlPath?: string | boolean | undefined;
        name?: string | undefined;
    }), "Options about cover images and cover page documents.">]>;
    readonly timeout: v.SchemaWithPipe<[v.NumberSchema<undefined>, v.DescriptionAction<number, "Timeout limit for waiting Vivliostyle process (ms). (default: `120000`)">]>;
    readonly documentProcessor: v.SchemaWithPipe<[v.GenericSchema<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, (option: StringifyMarkdownOptions, metadata: Metadata) => Processor, v.BaseIssue<unknown>>, v.MetadataAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, {
        readonly typeString: "(option: import(\"@vivliostyle/vfm\").StringifyMarkdownOptions, metadata: import(\"@vivliostyle/vfm\").Metadata) => import(\"unified\").Processor";
    }>, v.DescriptionAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, "Custom function to provide unified Processor from markdown into html">]>;
    readonly vfm: v.SchemaWithPipe<[Omit<v.LooseObjectSchema<{
        readonly style: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "Custom stylesheet path/URL.">]>;
        readonly partial: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Output markdown fragments.">]>;
        readonly title: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document title (ignored in partial mode).">]>;
        readonly language: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document language (ignored in partial mode).">]>;
        readonly replace: v.SchemaWithPipe<[v.ArraySchema<v.LooseObjectSchema<{
            readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
            readonly match: v.SchemaWithPipe<[v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string, (result: RegExpMatchArray, h: any) => Object | string, v.BaseIssue<unknown>>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
            }>]>;
        }, undefined>, undefined>, v.DescriptionAction<({
            match: (result: RegExpMatchArray, h: any) => Object | string;
            test: RegExp;
        } & {
            [key: string]: unknown;
        })[], "Replacement handler for HTML string.">]>;
        readonly hardLineBreaks: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Add `<br>` at the position of hard line breaks, without needing spaces.">]>;
        readonly disableFormatHtml: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Disable automatic HTML format.">]>;
        readonly math: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Enable math syntax.">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly style: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "Custom stylesheet path/URL.">]>, never>;
            readonly partial: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Output markdown fragments.">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document title (ignored in partial mode).">]>, never>;
            readonly language: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document language (ignored in partial mode).">]>, never>;
            readonly replace: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.LooseObjectSchema<{
                readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
                readonly match: v.SchemaWithPipe<[v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string, (result: RegExpMatchArray, h: any) => Object | string, v.BaseIssue<unknown>>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                    readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
                }>]>;
            }, undefined>, undefined>, v.DescriptionAction<({
                match: (result: RegExpMatchArray, h: any) => Object | string;
                test: RegExp;
            } & {
                [key: string]: unknown;
            })[], "Replacement handler for HTML string.">]>, never>;
            readonly hardLineBreaks: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Add `<br>` at the position of hard line breaks, without needing spaces.">]>, never>;
            readonly disableFormatHtml: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Disable automatic HTML format.">]>, never>;
            readonly math: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Enable math syntax.">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            title?: string | undefined;
            replace?: ({
                match: (result: RegExpMatchArray, h: any) => Object | string;
                test: RegExp;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            language?: string | undefined;
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }, v.BaseIssue<unknown> | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LooseObjectIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.InstanceIssue | v.BooleanIssue>;
        readonly _types?: {
            readonly input: {
                title?: string | undefined;
                replace?: ({
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                    test: RegExp;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                language?: string | undefined;
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            };
            readonly output: {
                title?: string | undefined;
                replace?: ({
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                    test: RegExp;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                language?: string | undefined;
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            };
            readonly issue: v.BaseIssue<unknown> | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LooseObjectIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.InstanceIssue | v.BooleanIssue;
        } | undefined;
    }, v.DescriptionAction<{
        title?: string | undefined;
        replace?: ({
            match: (result: RegExpMatchArray, h: any) => Object | string;
            test: RegExp;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        language?: string | undefined;
        style?: string | string[] | undefined;
        partial?: boolean | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }, "Option for convert Markdown to a stringify (HTML).">]>;
    readonly image: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify a docker image to render.">]>;
    readonly http: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "\n            Launch an HTTP server hosting contents instead of file protocol.\n            It is useful that requires CORS such as external web fonts.\n          ">]>;
    readonly viewer: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n            Specify a URL of displaying viewer instead of vivliostyle-cli's one.\n            It is useful that using own viewer that has staging features. (ex: `https://vivliostyle.vercel.app/`)\n          ">]>;
    readonly viewerParam: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "specify viewer parameters. (ex: `allowScripts=false&pixelRatio=16`)">]>;
    readonly browser: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"chromium", undefined>, v.LiteralSchema<"firefox", undefined>, v.LiteralSchema<"webkit", undefined>], undefined>, v.DescriptionAction<"chromium" | "firefox" | "webkit", "\n            EXPERIMENTAL SUPPORT: Specify a browser type to launch Vivliostyle viewer.\n            Currently, Firefox and Webkit support preview command only!\n          ">]>;
}, undefined>, "_types" | "_run" | "entries"> & {
    readonly entries: {
        readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Title">]>, never>;
        readonly author: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Author">]>, never>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[], "Theme package path(s) or URL(s) of css file.">]>, never>;
        readonly entryContext: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Directory of referencing entry file(s).">]>, never>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>, "Missing required field: path">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                path: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    path: string;
                };
                readonly output: {
                    path: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly format: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>;
            readonly renderMode: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>;
            readonly preflight: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>;
            readonly preflightOption: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly format: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>, never>;
                readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>, never>;
                readonly preflight: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>, never>;
                readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
            readonly _types?: {
                readonly input: {
                    format?: string | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly output: {
                    format?: string | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            path: string;
        } & {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, "OutputObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>, "Missing required field: path">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                path: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    path: string;
                };
                readonly output: {
                    path: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly format: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>;
            readonly renderMode: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>;
            readonly preflight: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>;
            readonly preflightOption: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly format: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>, never>;
                readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>, never>;
                readonly preflight: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>, never>;
                readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
            readonly _types?: {
                readonly input: {
                    format?: string | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly output: {
                    format?: string | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            path: string;
        } & {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, "OutputObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | ({
            path: string;
        } & {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[], "Options about outputs.">]>, never>;
        readonly workspaceDir: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n            Specify the directory where the intermediate files (manuscript HTMLs, publication.json, etc.) are saved.\n            If not specified, theses files are saved in the same directory as the input file.\n          ">]>, never>;
        readonly includeAssets: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.MetadataAction<string | string[], {
            readonly deprecated: true;
        }>, v.DescriptionAction<string | string[], "Use `copyAsset.includes` instead">]>, never>;
        readonly copyAsset: v.OptionalSchema<v.SchemaWithPipe<[Omit<v.ObjectSchema<{
            readonly includes: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to include as asset files.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>;
            readonly excludes: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to exclude from the asset file.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>;
            readonly includeFileExtensions: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to include as an asset file. (default: `[png, jpg, jpeg, svg, gif, webp, apng, ttf, otf, woff, woff2]`)">]>;
            readonly excludeFileExtensions: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to exclude as an asset file.">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly includes: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to include as asset files.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>, never>;
                readonly excludes: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to exclude from the asset file.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>, never>;
                readonly includeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to include as an asset file. (default: `[png, jpg, jpeg, svg, gif, webp, apng, ttf, otf, woff, woff2]`)">]>, never>;
                readonly excludeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to exclude as an asset file.">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            readonly _types?: {
                readonly input: {
                    includes?: string[] | undefined;
                    excludes?: string[] | undefined;
                    includeFileExtensions?: string[] | undefined;
                    excludeFileExtensions?: string[] | undefined;
                };
                readonly output: {
                    includes?: string[] | undefined;
                    excludes?: string[] | undefined;
                    includeFileExtensions?: string[] | undefined;
                    excludeFileExtensions?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>;
            } | undefined;
        }, v.DescriptionAction<{
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }, "Options about asset files to be copied when exporting output.">]>, never>;
        readonly size: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n            Output pdf size. (default: `letter`)\n            - preset: `A5`, `A4`, `A3`, `B5`, `B4`, `JIS-B5`, `JIS-B4`, `letter`, `legal`, `ledger`\n            - custom(comma separated): `182mm,257mm` or `8.5in,11in`\n          ">]>, never>;
        readonly pressReady: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "\n            Make generated PDF compatible with press ready PDF/X-1a. (default: `false`)\n            This option is equivalent with `\"preflight\": \"press-ready\"`\n          ">]>, never>;
        readonly language: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Language">]>, never>;
        readonly readingProgression: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"ltr", undefined>, v.LiteralSchema<"rtl", undefined>], undefined>, v.DescriptionAction<"ltr" | "rtl", "Specify the reading progression of the document. This is typically determined automatically by the CSS writing-mode, so use this option only if you need to set it explicitly.">]>, never>;
        readonly toc: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[Omit<v.ObjectSchema<{
            readonly title: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the title of the generated ToC document.">]>;
            readonly htmlPath: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the location where the generated ToC document will be saved. (default: `index.html`)">]>;
            readonly sectionDepth: v.SchemaWithPipe<[v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, "Specify the depth of the section to be included in the ToC document. (default: `0`)">]>;
            readonly transformDocumentList: v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, (nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocument, StructuredDocument, v.BaseIssue<unknown>>];
            }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, "Specify the transform function for the document list.">]>;
            readonly transformSectionList: v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, (nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection, StructuredDocumentSection, v.BaseIssue<unknown>>];
            }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, "Specify the transform function for the section list.">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the title of the generated ToC document.">]>, never>;
                readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the location where the generated ToC document will be saved. (default: `index.html`)">]>, never>;
                readonly sectionDepth: v.OptionalSchema<v.SchemaWithPipe<[v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, "Specify the depth of the section to be included in the ToC document. (default: `0`)">]>, never>;
                readonly transformDocumentList: v.OptionalSchema<v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any, (nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any, {
                    readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
                    readonly typeReferences: readonly [v.GenericSchema<StructuredDocument, StructuredDocument, v.BaseIssue<unknown>>];
                }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any, "Specify the transform function for the document list.">]>, never>;
                readonly transformSectionList: v.OptionalSchema<v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any, (nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any, {
                    readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
                    readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection, StructuredDocumentSection, v.BaseIssue<unknown>>];
                }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any, "Specify the transform function for the section list.">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            }, v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>>;
            readonly _types?: {
                readonly input: {
                    title?: string | undefined;
                    htmlPath?: string | undefined;
                    sectionDepth?: number | undefined;
                    transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                    transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                };
                readonly output: {
                    title?: string | undefined;
                    htmlPath?: string | undefined;
                    sectionDepth?: number | undefined;
                    transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                    transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                };
                readonly issue: v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>;
            } | undefined;
        }, v.BooleanSchema<undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }, "Options about Table of Contents (ToC) documents.">]>, never>;
        readonly tocTitle: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.MetadataAction<string, {
            readonly deprecated: true;
        }>, v.DescriptionAction<string, "Use `toc.title` instead">]>, never>;
        readonly cover: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly src: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the cover image to be used for the cover page.">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly src: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the cover image to be used for the cover page.">]>, "Missing required field: src">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                src: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    src: string;
                };
                readonly output: {
                    src: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly name: v.SchemaWithPipe<[v.StringSchema<undefined>, v.DescriptionAction<string, "Specify alternative text for the cover image.">]>;
            readonly htmlPath: v.SchemaWithPipe<[v.UnionSchema<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, "\n                      Specify the location where the generated cover document will be saved. (default: cover.html)\n                      If falsy value is set, the cover document won't be generated.\n                    ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly name: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.DescriptionAction<string, "Specify alternative text for the cover image.">]>, never>;
                readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, "\n                      Specify the location where the generated cover document will be saved. (default: cover.html)\n                      If falsy value is set, the cover document won't be generated.\n                    ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                htmlPath?: string | boolean | undefined;
                name?: string | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>>;
            readonly _types?: {
                readonly input: {
                    htmlPath?: string | boolean | undefined;
                    name?: string | undefined;
                };
                readonly output: {
                    htmlPath?: string | boolean | undefined;
                    name?: string | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>;
            } | undefined;
        }], undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | ({
            src: string;
        } & {
            htmlPath?: string | boolean | undefined;
            name?: string | undefined;
        }), "Options about cover images and cover page documents.">]>, never>;
        readonly timeout: v.OptionalSchema<v.SchemaWithPipe<[v.NumberSchema<undefined>, v.DescriptionAction<number, "Timeout limit for waiting Vivliostyle process (ms). (default: `120000`)">]>, never>;
        readonly documentProcessor: v.OptionalSchema<v.SchemaWithPipe<[v.GenericSchema<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, (option: StringifyMarkdownOptions, metadata: Metadata) => Processor, v.BaseIssue<unknown>>, v.MetadataAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, {
            readonly typeString: "(option: import(\"@vivliostyle/vfm\").StringifyMarkdownOptions, metadata: import(\"@vivliostyle/vfm\").Metadata) => import(\"unified\").Processor";
        }>, v.DescriptionAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, "Custom function to provide unified Processor from markdown into html">]>, never>;
        readonly vfm: v.OptionalSchema<v.SchemaWithPipe<[Omit<v.LooseObjectSchema<{
            readonly style: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "Custom stylesheet path/URL.">]>;
            readonly partial: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Output markdown fragments.">]>;
            readonly title: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document title (ignored in partial mode).">]>;
            readonly language: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document language (ignored in partial mode).">]>;
            readonly replace: v.SchemaWithPipe<[v.ArraySchema<v.LooseObjectSchema<{
                readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
                readonly match: v.SchemaWithPipe<[v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string, (result: RegExpMatchArray, h: any) => Object | string, v.BaseIssue<unknown>>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                    readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
                }>]>;
            }, undefined>, undefined>, v.DescriptionAction<({
                match: (result: RegExpMatchArray, h: any) => Object | string;
                test: RegExp;
            } & {
                [key: string]: unknown;
            })[], "Replacement handler for HTML string.">]>;
            readonly hardLineBreaks: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Add `<br>` at the position of hard line breaks, without needing spaces.">]>;
            readonly disableFormatHtml: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Disable automatic HTML format.">]>;
            readonly math: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Enable math syntax.">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly style: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "Custom stylesheet path/URL.">]>, never>;
                readonly partial: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Output markdown fragments.">]>, never>;
                readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document title (ignored in partial mode).">]>, never>;
                readonly language: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document language (ignored in partial mode).">]>, never>;
                readonly replace: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.LooseObjectSchema<{
                    readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
                    readonly match: v.SchemaWithPipe<[v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string, (result: RegExpMatchArray, h: any) => Object | string, v.BaseIssue<unknown>>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                        readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
                    }>]>;
                }, undefined>, undefined>, v.DescriptionAction<({
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                    test: RegExp;
                } & {
                    [key: string]: unknown;
                })[], "Replacement handler for HTML string.">]>, never>;
                readonly hardLineBreaks: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Add `<br>` at the position of hard line breaks, without needing spaces.">]>, never>;
                readonly disableFormatHtml: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Disable automatic HTML format.">]>, never>;
                readonly math: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Enable math syntax.">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                title?: string | undefined;
                replace?: ({
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                    test: RegExp;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                language?: string | undefined;
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }, v.BaseIssue<unknown> | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LooseObjectIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.InstanceIssue | v.BooleanIssue>;
            readonly _types?: {
                readonly input: {
                    title?: string | undefined;
                    replace?: ({
                        match: (result: RegExpMatchArray, h: any) => Object | string;
                        test: RegExp;
                    } & {
                        [key: string]: unknown;
                    })[] | undefined;
                    language?: string | undefined;
                    style?: string | string[] | undefined;
                    partial?: boolean | undefined;
                    hardLineBreaks?: boolean | undefined;
                    disableFormatHtml?: boolean | undefined;
                    math?: boolean | undefined;
                } & {
                    [key: string]: unknown;
                };
                readonly output: {
                    title?: string | undefined;
                    replace?: ({
                        match: (result: RegExpMatchArray, h: any) => Object | string;
                        test: RegExp;
                    } & {
                        [key: string]: unknown;
                    })[] | undefined;
                    language?: string | undefined;
                    style?: string | string[] | undefined;
                    partial?: boolean | undefined;
                    hardLineBreaks?: boolean | undefined;
                    disableFormatHtml?: boolean | undefined;
                    math?: boolean | undefined;
                } & {
                    [key: string]: unknown;
                };
                readonly issue: v.BaseIssue<unknown> | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LooseObjectIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.InstanceIssue | v.BooleanIssue;
            } | undefined;
        }, v.DescriptionAction<{
            title?: string | undefined;
            replace?: ({
                match: (result: RegExpMatchArray, h: any) => Object | string;
                test: RegExp;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            language?: string | undefined;
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }, "Option for convert Markdown to a stringify (HTML).">]>, never>;
        readonly image: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify a docker image to render.">]>, never>;
        readonly http: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "\n            Launch an HTTP server hosting contents instead of file protocol.\n            It is useful that requires CORS such as external web fonts.\n          ">]>, never>;
        readonly viewer: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n            Specify a URL of displaying viewer instead of vivliostyle-cli's one.\n            It is useful that using own viewer that has staging features. (ex: `https://vivliostyle.vercel.app/`)\n          ">]>, never>;
        readonly viewerParam: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "specify viewer parameters. (ex: `allowScripts=false&pixelRatio=16`)">]>, never>;
        readonly browser: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"chromium", undefined>, v.LiteralSchema<"firefox", undefined>, v.LiteralSchema<"webkit", undefined>], undefined>, v.DescriptionAction<"chromium" | "firefox" | "webkit", "\n            EXPERIMENTAL SUPPORT: Specify a browser type to launch Vivliostyle viewer.\n            Currently, Firefox and Webkit support preview command only!\n          ">]>, never>;
    };
    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
        output?: string | ({
            path: string;
        } & {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[] | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        cover?: string | ({
            src: string;
        } & {
            htmlPath?: string | boolean | undefined;
            name?: string | undefined;
        }) | undefined;
        author?: string | undefined;
        entryContext?: string | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string | string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            title?: string | undefined;
            replace?: ({
                match: (result: RegExpMatchArray, h: any) => Object | string;
                test: RegExp;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            language?: string | undefined;
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
    }, v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LooseObjectIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.InstanceIssue | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>> | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6> | v.UnionIssue<v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>>>;
    readonly _types?: {
        readonly input: {
            output?: string | ({
                path: string;
            } & {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            cover?: string | ({
                src: string;
            } & {
                htmlPath?: string | boolean | undefined;
                name?: string | undefined;
            }) | undefined;
            author?: string | undefined;
            entryContext?: string | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                title?: string | undefined;
                replace?: ({
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                    test: RegExp;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                language?: string | undefined;
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
        };
        readonly output: {
            output?: string | ({
                path: string;
            } & {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            cover?: string | ({
                src: string;
            } & {
                htmlPath?: string | boolean | undefined;
                name?: string | undefined;
            }) | undefined;
            author?: string | undefined;
            entryContext?: string | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                title?: string | undefined;
                replace?: ({
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                    test: RegExp;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                language?: string | undefined;
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
        };
        readonly issue: v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LooseObjectIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.InstanceIssue | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>> | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6> | v.UnionIssue<v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>>;
    } | undefined;
}], undefined>, v.TitleAction<{
    entry: string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | (string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | {
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    })[];
} & {
    output?: string | ({
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }) | (string | ({
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }))[] | undefined;
    title?: string | undefined;
    theme?: string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }))[] | undefined;
    cover?: string | ({
        src: string;
    } & {
        htmlPath?: string | boolean | undefined;
        name?: string | undefined;
    }) | undefined;
    author?: string | undefined;
    entryContext?: string | undefined;
    workspaceDir?: string | undefined;
    includeAssets?: string | string[] | undefined;
    copyAsset?: {
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    } | undefined;
    size?: string | undefined;
    pressReady?: boolean | undefined;
    language?: string | undefined;
    readingProgression?: "ltr" | "rtl" | undefined;
    toc?: string | boolean | {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    } | undefined;
    tocTitle?: string | undefined;
    timeout?: number | undefined;
    documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
    vfm?: ({
        title?: string | undefined;
        replace?: ({
            match: (result: RegExpMatchArray, h: any) => Object | string;
            test: RegExp;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        language?: string | undefined;
        style?: string | string[] | undefined;
        partial?: boolean | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }) | undefined;
    image?: string | undefined;
    http?: boolean | undefined;
    viewer?: string | undefined;
    viewerParam?: string | undefined;
    browser?: "chromium" | "firefox" | "webkit" | undefined;
}, "VivliostyleConfigEntry">]>;
export type VivliostyleConfigEntry = v.InferInput<typeof VivliostyleConfigEntry>;
/** @hidden */
export declare const VivliostyleConfigSchema: v.SchemaWithPipe<[v.UnionSchema<[v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
    readonly entry: v.SchemaWithPipe<[v.UnionSchema<[v.SchemaWithPipe<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<[v.ObjectSchema<{
        readonly rel: v.LiteralSchema<"contents", undefined>;
        readonly path: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        readonly pageBreakBefore: v.SchemaWithPipe<[v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, never>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, "\n        Specify the page break position before this document.\n        It is useful when you want to specify which side a first page of the document should be placed on a two-page spread.\n      ">]>;
        readonly pageCounterReset: v.SchemaWithPipe<[v.OptionalSchema<v.SchemaWithPipe<[v.NumberSchema<undefined>, v.SafeIntegerAction<number, undefined>]>, never>, v.DescriptionAction<number | undefined, "\n        Reset the starting page number of this document by the specified integer.\n        It is useful when you want to control page numbers when including a page.\n      ">]>;
    }, undefined>, v.TitleAction<{
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    }, "ContentsEntryObject">]>, v.SchemaWithPipe<[v.ObjectSchema<{
        readonly rel: v.LiteralSchema<"cover", undefined>;
        readonly path: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        readonly imageSrc: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly imageAlt: v.OptionalSchema<v.StringSchema<undefined>, never>;
        readonly pageBreakBefore: v.SchemaWithPipe<[v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, never>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, "\n      Specify the page break position before this document.\n      It is useful when you want to specify which side a first page of the document should be placed on a two-page spread.\n    ">]>;
    }, undefined>, v.TitleAction<{
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    }, "CoverEntryObject">]>, v.SchemaWithPipe<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>>;
        readonly _types?: {
            readonly input: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            };
            readonly output: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>;
        } | undefined;
    }, v.TitleAction<{
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    }, "ArticleEntryObject">]>], undefined>], undefined>, undefined>, v.MinLengthAction<(string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | {
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    })[], 1, "At least one entry is required">]>, v.SchemaWithPipe<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>>;
        readonly _types?: {
            readonly input: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            };
            readonly output: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>;
        } | undefined;
    }, v.TitleAction<{
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    }, "ArticleEntryObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | (string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | {
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    })[], "Entry file(s) of document.">]>;
}, undefined>, "_types" | "_run" | "entries"> & {
    readonly entries: {
        readonly entry: v.NonOptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.SchemaWithPipe<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<[v.ObjectSchema<{
            readonly rel: v.LiteralSchema<"contents", undefined>;
            readonly path: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            readonly pageBreakBefore: v.SchemaWithPipe<[v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, never>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, "\n        Specify the page break position before this document.\n        It is useful when you want to specify which side a first page of the document should be placed on a two-page spread.\n      ">]>;
            readonly pageCounterReset: v.SchemaWithPipe<[v.OptionalSchema<v.SchemaWithPipe<[v.NumberSchema<undefined>, v.SafeIntegerAction<number, undefined>]>, never>, v.DescriptionAction<number | undefined, "\n        Reset the starting page number of this document by the specified integer.\n        It is useful when you want to control page numbers when including a page.\n      ">]>;
        }, undefined>, v.TitleAction<{
            rel: "contents";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        }, "ContentsEntryObject">]>, v.SchemaWithPipe<[v.ObjectSchema<{
            readonly rel: v.LiteralSchema<"cover", undefined>;
            readonly path: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            readonly imageSrc: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly imageAlt: v.OptionalSchema<v.StringSchema<undefined>, never>;
            readonly pageBreakBefore: v.SchemaWithPipe<[v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, never>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, "\n      Specify the page break position before this document.\n      It is useful when you want to specify which side a first page of the document should be placed on a two-page spread.\n    ">]>;
        }, undefined>, v.TitleAction<{
            rel: "cover";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
        }, "CoverEntryObject">]>, v.SchemaWithPipe<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
                readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
                readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
                readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly _types?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        import?: string | string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                    readonly _types?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string | string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly _types?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        import?: string | string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                    readonly _types?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string | string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
                readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
                readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>>;
            readonly _types?: {
                readonly input: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                };
                readonly output: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>;
            } | undefined;
        }, v.TitleAction<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        }, "ArticleEntryObject">]>], undefined>], undefined>, undefined>, v.MinLengthAction<(string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | {
            rel: "contents";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
        })[], 1, "At least one entry is required">]>, v.SchemaWithPipe<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
                readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
                readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
                readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly _types?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        import?: string | string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                    readonly _types?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string | string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly _types?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        import?: string | string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                    readonly _types?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string | string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
                readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
                readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>>;
            readonly _types?: {
                readonly input: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                };
                readonly output: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>;
            } | undefined;
        }, v.TitleAction<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        }, "ArticleEntryObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | {
            rel: "contents";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
        })[], "Entry file(s) of document.">]>, "Missing required field: entry">;
    };
    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
        entry: string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | {
            rel: "contents";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
        })[];
    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | {
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    })[], 1> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | {
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    })[], 1>>>;
    readonly _types?: {
        readonly input: {
            entry: string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | {
                rel: "contents";
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                path?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                path?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
            })[];
        };
        readonly output: {
            entry: string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | {
                rel: "contents";
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                path?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                path?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
            })[];
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | {
            rel: "contents";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
        })[], 1> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | {
            rel: "contents";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
        })[], 1>>;
    } | undefined;
}, Omit<v.ObjectSchema<{
    readonly title: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Title">]>;
    readonly author: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Author">]>;
    readonly theme: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            import?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
        readonly _types?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            import?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
        readonly _types?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }))[], "Theme package path(s) or URL(s) of css file.">]>;
    readonly entryContext: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Directory of referencing entry file(s).">]>;
    readonly output: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>, "Missing required field: path">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            path: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                path: string;
            };
            readonly output: {
                path: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly format: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>;
        readonly renderMode: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>;
        readonly preflight: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>;
        readonly preflightOption: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly format: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>, never>;
            readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>, never>;
            readonly preflight: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>, never>;
            readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
        readonly _types?: {
            readonly input: {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly output: {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }, "OutputObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>, "Missing required field: path">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            path: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                path: string;
            };
            readonly output: {
                path: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly format: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>;
        readonly renderMode: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>;
        readonly preflight: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>;
        readonly preflightOption: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly format: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>, never>;
            readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>, never>;
            readonly preflight: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>, never>;
            readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
        readonly _types?: {
            readonly input: {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly output: {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }, "OutputObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | ({
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }) | (string | ({
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }))[], "Options about outputs.">]>;
    readonly workspaceDir: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n            Specify the directory where the intermediate files (manuscript HTMLs, publication.json, etc.) are saved.\n            If not specified, theses files are saved in the same directory as the input file.\n          ">]>;
    /** @deprecated */
    readonly includeAssets: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.MetadataAction<string | string[], {
        readonly deprecated: true;
    }>, v.DescriptionAction<string | string[], "Use `copyAsset.includes` instead">]>;
    readonly copyAsset: v.SchemaWithPipe<[Omit<v.ObjectSchema<{
        readonly includes: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to include as asset files.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>;
        readonly excludes: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to exclude from the asset file.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>;
        readonly includeFileExtensions: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to include as an asset file. (default: `[png, jpg, jpeg, svg, gif, webp, apng, ttf, otf, woff, woff2]`)">]>;
        readonly excludeFileExtensions: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to exclude as an asset file.">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly includes: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to include as asset files.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>, never>;
            readonly excludes: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to exclude from the asset file.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>, never>;
            readonly includeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to include as an asset file. (default: `[png, jpg, jpeg, svg, gif, webp, apng, ttf, otf, woff, woff2]`)">]>, never>;
            readonly excludeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to exclude as an asset file.">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        readonly _types?: {
            readonly input: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            };
            readonly output: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>;
        } | undefined;
    }, v.DescriptionAction<{
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    }, "Options about asset files to be copied when exporting output.">]>;
    readonly size: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n            Output pdf size. (default: `letter`)\n            - preset: `A5`, `A4`, `A3`, `B5`, `B4`, `JIS-B5`, `JIS-B4`, `letter`, `legal`, `ledger`\n            - custom(comma separated): `182mm,257mm` or `8.5in,11in`\n          ">]>;
    readonly pressReady: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "\n            Make generated PDF compatible with press ready PDF/X-1a. (default: `false`)\n            This option is equivalent with `\"preflight\": \"press-ready\"`\n          ">]>;
    readonly language: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Language">]>;
    readonly readingProgression: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"ltr", undefined>, v.LiteralSchema<"rtl", undefined>], undefined>, v.DescriptionAction<"ltr" | "rtl", "Specify the reading progression of the document. This is typically determined automatically by the CSS writing-mode, so use this option only if you need to set it explicitly.">]>;
    readonly toc: v.SchemaWithPipe<[v.UnionSchema<[Omit<v.ObjectSchema<{
        readonly title: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the title of the generated ToC document.">]>;
        readonly htmlPath: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the location where the generated ToC document will be saved. (default: `index.html`)">]>;
        readonly sectionDepth: v.SchemaWithPipe<[v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, "Specify the depth of the section to be included in the ToC document. (default: `0`)">]>;
        readonly transformDocumentList: v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, (nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, {
            readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
            readonly typeReferences: readonly [v.GenericSchema<StructuredDocument, StructuredDocument, v.BaseIssue<unknown>>];
        }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, "Specify the transform function for the document list.">]>;
        readonly transformSectionList: v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, (nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, {
            readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
            readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection, StructuredDocumentSection, v.BaseIssue<unknown>>];
        }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, "Specify the transform function for the section list.">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the title of the generated ToC document.">]>, never>;
            readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the location where the generated ToC document will be saved. (default: `index.html`)">]>, never>;
            readonly sectionDepth: v.OptionalSchema<v.SchemaWithPipe<[v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, "Specify the depth of the section to be included in the ToC document. (default: `0`)">]>, never>;
            readonly transformDocumentList: v.OptionalSchema<v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, (nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocument, StructuredDocument, v.BaseIssue<unknown>>];
            }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, "Specify the transform function for the document list.">]>, never>;
            readonly transformSectionList: v.OptionalSchema<v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, (nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection, StructuredDocumentSection, v.BaseIssue<unknown>>];
            }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, "Specify the transform function for the section list.">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }, v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>>;
        readonly _types?: {
            readonly input: {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            };
            readonly output: {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            };
            readonly issue: v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>;
        } | undefined;
    }, v.BooleanSchema<undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean | {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    }, "Options about Table of Contents (ToC) documents.">]>;
    /** @deprecated */
    readonly tocTitle: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.MetadataAction<string, {
        readonly deprecated: true;
    }>, v.DescriptionAction<string, "Use `toc.title` instead">]>;
    readonly cover: v.SchemaWithPipe<[v.UnionSchema<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly src: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the cover image to be used for the cover page.">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly src: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the cover image to be used for the cover page.">]>, "Missing required field: src">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            src: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                src: string;
            };
            readonly output: {
                src: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly name: v.SchemaWithPipe<[v.StringSchema<undefined>, v.DescriptionAction<string, "Specify alternative text for the cover image.">]>;
        readonly htmlPath: v.SchemaWithPipe<[v.UnionSchema<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, "\n                      Specify the location where the generated cover document will be saved. (default: cover.html)\n                      If falsy value is set, the cover document won't be generated.\n                    ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly name: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.DescriptionAction<string, "Specify alternative text for the cover image.">]>, never>;
            readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, "\n                      Specify the location where the generated cover document will be saved. (default: cover.html)\n                      If falsy value is set, the cover document won't be generated.\n                    ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            htmlPath?: string | boolean | undefined;
            name?: string | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>>;
        readonly _types?: {
            readonly input: {
                htmlPath?: string | boolean | undefined;
                name?: string | undefined;
            };
            readonly output: {
                htmlPath?: string | boolean | undefined;
                name?: string | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>;
        } | undefined;
    }], undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | ({
        src: string;
    } & {
        htmlPath?: string | boolean | undefined;
        name?: string | undefined;
    }), "Options about cover images and cover page documents.">]>;
    readonly timeout: v.SchemaWithPipe<[v.NumberSchema<undefined>, v.DescriptionAction<number, "Timeout limit for waiting Vivliostyle process (ms). (default: `120000`)">]>;
    readonly documentProcessor: v.SchemaWithPipe<[v.GenericSchema<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, (option: StringifyMarkdownOptions, metadata: Metadata) => Processor, v.BaseIssue<unknown>>, v.MetadataAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, {
        readonly typeString: "(option: import(\"@vivliostyle/vfm\").StringifyMarkdownOptions, metadata: import(\"@vivliostyle/vfm\").Metadata) => import(\"unified\").Processor";
    }>, v.DescriptionAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, "Custom function to provide unified Processor from markdown into html">]>;
    readonly vfm: v.SchemaWithPipe<[Omit<v.LooseObjectSchema<{
        readonly style: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "Custom stylesheet path/URL.">]>;
        readonly partial: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Output markdown fragments.">]>;
        readonly title: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document title (ignored in partial mode).">]>;
        readonly language: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document language (ignored in partial mode).">]>;
        readonly replace: v.SchemaWithPipe<[v.ArraySchema<v.LooseObjectSchema<{
            readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
            readonly match: v.SchemaWithPipe<[v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string, (result: RegExpMatchArray, h: any) => Object | string, v.BaseIssue<unknown>>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
            }>]>;
        }, undefined>, undefined>, v.DescriptionAction<({
            match: (result: RegExpMatchArray, h: any) => Object | string;
            test: RegExp;
        } & {
            [key: string]: unknown;
        })[], "Replacement handler for HTML string.">]>;
        readonly hardLineBreaks: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Add `<br>` at the position of hard line breaks, without needing spaces.">]>;
        readonly disableFormatHtml: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Disable automatic HTML format.">]>;
        readonly math: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Enable math syntax.">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly style: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "Custom stylesheet path/URL.">]>, never>;
            readonly partial: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Output markdown fragments.">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document title (ignored in partial mode).">]>, never>;
            readonly language: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document language (ignored in partial mode).">]>, never>;
            readonly replace: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.LooseObjectSchema<{
                readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
                readonly match: v.SchemaWithPipe<[v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string, (result: RegExpMatchArray, h: any) => Object | string, v.BaseIssue<unknown>>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                    readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
                }>]>;
            }, undefined>, undefined>, v.DescriptionAction<({
                match: (result: RegExpMatchArray, h: any) => Object | string;
                test: RegExp;
            } & {
                [key: string]: unknown;
            })[], "Replacement handler for HTML string.">]>, never>;
            readonly hardLineBreaks: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Add `<br>` at the position of hard line breaks, without needing spaces.">]>, never>;
            readonly disableFormatHtml: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Disable automatic HTML format.">]>, never>;
            readonly math: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Enable math syntax.">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            title?: string | undefined;
            replace?: ({
                match: (result: RegExpMatchArray, h: any) => Object | string;
                test: RegExp;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            language?: string | undefined;
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }, v.BaseIssue<unknown> | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LooseObjectIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.InstanceIssue | v.BooleanIssue>;
        readonly _types?: {
            readonly input: {
                title?: string | undefined;
                replace?: ({
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                    test: RegExp;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                language?: string | undefined;
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            };
            readonly output: {
                title?: string | undefined;
                replace?: ({
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                    test: RegExp;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                language?: string | undefined;
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            };
            readonly issue: v.BaseIssue<unknown> | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LooseObjectIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.InstanceIssue | v.BooleanIssue;
        } | undefined;
    }, v.DescriptionAction<{
        title?: string | undefined;
        replace?: ({
            match: (result: RegExpMatchArray, h: any) => Object | string;
            test: RegExp;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        language?: string | undefined;
        style?: string | string[] | undefined;
        partial?: boolean | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }, "Option for convert Markdown to a stringify (HTML).">]>;
    readonly image: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify a docker image to render.">]>;
    readonly http: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "\n            Launch an HTTP server hosting contents instead of file protocol.\n            It is useful that requires CORS such as external web fonts.\n          ">]>;
    readonly viewer: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n            Specify a URL of displaying viewer instead of vivliostyle-cli's one.\n            It is useful that using own viewer that has staging features. (ex: `https://vivliostyle.vercel.app/`)\n          ">]>;
    readonly viewerParam: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "specify viewer parameters. (ex: `allowScripts=false&pixelRatio=16`)">]>;
    readonly browser: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"chromium", undefined>, v.LiteralSchema<"firefox", undefined>, v.LiteralSchema<"webkit", undefined>], undefined>, v.DescriptionAction<"chromium" | "firefox" | "webkit", "\n            EXPERIMENTAL SUPPORT: Specify a browser type to launch Vivliostyle viewer.\n            Currently, Firefox and Webkit support preview command only!\n          ">]>;
}, undefined>, "_types" | "_run" | "entries"> & {
    readonly entries: {
        readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Title">]>, never>;
        readonly author: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Author">]>, never>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[], "Theme package path(s) or URL(s) of css file.">]>, never>;
        readonly entryContext: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Directory of referencing entry file(s).">]>, never>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>, "Missing required field: path">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                path: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    path: string;
                };
                readonly output: {
                    path: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly format: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>;
            readonly renderMode: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>;
            readonly preflight: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>;
            readonly preflightOption: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly format: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>, never>;
                readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>, never>;
                readonly preflight: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>, never>;
                readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
            readonly _types?: {
                readonly input: {
                    format?: string | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly output: {
                    format?: string | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            path: string;
        } & {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, "OutputObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>, "Missing required field: path">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                path: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    path: string;
                };
                readonly output: {
                    path: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly format: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>;
            readonly renderMode: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>;
            readonly preflight: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>;
            readonly preflightOption: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly format: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>, never>;
                readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>, never>;
                readonly preflight: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>, never>;
                readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
            readonly _types?: {
                readonly input: {
                    format?: string | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly output: {
                    format?: string | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            path: string;
        } & {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, "OutputObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | ({
            path: string;
        } & {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[], "Options about outputs.">]>, never>;
        readonly workspaceDir: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n            Specify the directory where the intermediate files (manuscript HTMLs, publication.json, etc.) are saved.\n            If not specified, theses files are saved in the same directory as the input file.\n          ">]>, never>;
        readonly includeAssets: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.MetadataAction<string | string[], {
            readonly deprecated: true;
        }>, v.DescriptionAction<string | string[], "Use `copyAsset.includes` instead">]>, never>;
        readonly copyAsset: v.OptionalSchema<v.SchemaWithPipe<[Omit<v.ObjectSchema<{
            readonly includes: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to include as asset files.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>;
            readonly excludes: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to exclude from the asset file.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>;
            readonly includeFileExtensions: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to include as an asset file. (default: `[png, jpg, jpeg, svg, gif, webp, apng, ttf, otf, woff, woff2]`)">]>;
            readonly excludeFileExtensions: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to exclude as an asset file.">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly includes: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to include as asset files.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>, never>;
                readonly excludes: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to exclude from the asset file.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>, never>;
                readonly includeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to include as an asset file. (default: `[png, jpg, jpeg, svg, gif, webp, apng, ttf, otf, woff, woff2]`)">]>, never>;
                readonly excludeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to exclude as an asset file.">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            readonly _types?: {
                readonly input: {
                    includes?: string[] | undefined;
                    excludes?: string[] | undefined;
                    includeFileExtensions?: string[] | undefined;
                    excludeFileExtensions?: string[] | undefined;
                };
                readonly output: {
                    includes?: string[] | undefined;
                    excludes?: string[] | undefined;
                    includeFileExtensions?: string[] | undefined;
                    excludeFileExtensions?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>;
            } | undefined;
        }, v.DescriptionAction<{
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }, "Options about asset files to be copied when exporting output.">]>, never>;
        readonly size: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n            Output pdf size. (default: `letter`)\n            - preset: `A5`, `A4`, `A3`, `B5`, `B4`, `JIS-B5`, `JIS-B4`, `letter`, `legal`, `ledger`\n            - custom(comma separated): `182mm,257mm` or `8.5in,11in`\n          ">]>, never>;
        readonly pressReady: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "\n            Make generated PDF compatible with press ready PDF/X-1a. (default: `false`)\n            This option is equivalent with `\"preflight\": \"press-ready\"`\n          ">]>, never>;
        readonly language: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Language">]>, never>;
        readonly readingProgression: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"ltr", undefined>, v.LiteralSchema<"rtl", undefined>], undefined>, v.DescriptionAction<"ltr" | "rtl", "Specify the reading progression of the document. This is typically determined automatically by the CSS writing-mode, so use this option only if you need to set it explicitly.">]>, never>;
        readonly toc: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[Omit<v.ObjectSchema<{
            readonly title: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the title of the generated ToC document.">]>;
            readonly htmlPath: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the location where the generated ToC document will be saved. (default: `index.html`)">]>;
            readonly sectionDepth: v.SchemaWithPipe<[v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, "Specify the depth of the section to be included in the ToC document. (default: `0`)">]>;
            readonly transformDocumentList: v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, (nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocument, StructuredDocument, v.BaseIssue<unknown>>];
            }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, "Specify the transform function for the document list.">]>;
            readonly transformSectionList: v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, (nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection, StructuredDocumentSection, v.BaseIssue<unknown>>];
            }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, "Specify the transform function for the section list.">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the title of the generated ToC document.">]>, never>;
                readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the location where the generated ToC document will be saved. (default: `index.html`)">]>, never>;
                readonly sectionDepth: v.OptionalSchema<v.SchemaWithPipe<[v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, "Specify the depth of the section to be included in the ToC document. (default: `0`)">]>, never>;
                readonly transformDocumentList: v.OptionalSchema<v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any, (nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any, {
                    readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
                    readonly typeReferences: readonly [v.GenericSchema<StructuredDocument, StructuredDocument, v.BaseIssue<unknown>>];
                }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any, "Specify the transform function for the document list.">]>, never>;
                readonly transformSectionList: v.OptionalSchema<v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any, (nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any, {
                    readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
                    readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection, StructuredDocumentSection, v.BaseIssue<unknown>>];
                }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any, "Specify the transform function for the section list.">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            }, v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>>;
            readonly _types?: {
                readonly input: {
                    title?: string | undefined;
                    htmlPath?: string | undefined;
                    sectionDepth?: number | undefined;
                    transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                    transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                };
                readonly output: {
                    title?: string | undefined;
                    htmlPath?: string | undefined;
                    sectionDepth?: number | undefined;
                    transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                    transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                };
                readonly issue: v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>;
            } | undefined;
        }, v.BooleanSchema<undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }, "Options about Table of Contents (ToC) documents.">]>, never>;
        readonly tocTitle: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.MetadataAction<string, {
            readonly deprecated: true;
        }>, v.DescriptionAction<string, "Use `toc.title` instead">]>, never>;
        readonly cover: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly src: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the cover image to be used for the cover page.">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly src: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the cover image to be used for the cover page.">]>, "Missing required field: src">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                src: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    src: string;
                };
                readonly output: {
                    src: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly name: v.SchemaWithPipe<[v.StringSchema<undefined>, v.DescriptionAction<string, "Specify alternative text for the cover image.">]>;
            readonly htmlPath: v.SchemaWithPipe<[v.UnionSchema<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, "\n                      Specify the location where the generated cover document will be saved. (default: cover.html)\n                      If falsy value is set, the cover document won't be generated.\n                    ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly name: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.DescriptionAction<string, "Specify alternative text for the cover image.">]>, never>;
                readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, "\n                      Specify the location where the generated cover document will be saved. (default: cover.html)\n                      If falsy value is set, the cover document won't be generated.\n                    ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                htmlPath?: string | boolean | undefined;
                name?: string | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>>;
            readonly _types?: {
                readonly input: {
                    htmlPath?: string | boolean | undefined;
                    name?: string | undefined;
                };
                readonly output: {
                    htmlPath?: string | boolean | undefined;
                    name?: string | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>;
            } | undefined;
        }], undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | ({
            src: string;
        } & {
            htmlPath?: string | boolean | undefined;
            name?: string | undefined;
        }), "Options about cover images and cover page documents.">]>, never>;
        readonly timeout: v.OptionalSchema<v.SchemaWithPipe<[v.NumberSchema<undefined>, v.DescriptionAction<number, "Timeout limit for waiting Vivliostyle process (ms). (default: `120000`)">]>, never>;
        readonly documentProcessor: v.OptionalSchema<v.SchemaWithPipe<[v.GenericSchema<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, (option: StringifyMarkdownOptions, metadata: Metadata) => Processor, v.BaseIssue<unknown>>, v.MetadataAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, {
            readonly typeString: "(option: import(\"@vivliostyle/vfm\").StringifyMarkdownOptions, metadata: import(\"@vivliostyle/vfm\").Metadata) => import(\"unified\").Processor";
        }>, v.DescriptionAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, "Custom function to provide unified Processor from markdown into html">]>, never>;
        readonly vfm: v.OptionalSchema<v.SchemaWithPipe<[Omit<v.LooseObjectSchema<{
            readonly style: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "Custom stylesheet path/URL.">]>;
            readonly partial: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Output markdown fragments.">]>;
            readonly title: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document title (ignored in partial mode).">]>;
            readonly language: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document language (ignored in partial mode).">]>;
            readonly replace: v.SchemaWithPipe<[v.ArraySchema<v.LooseObjectSchema<{
                readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
                readonly match: v.SchemaWithPipe<[v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string, (result: RegExpMatchArray, h: any) => Object | string, v.BaseIssue<unknown>>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                    readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
                }>]>;
            }, undefined>, undefined>, v.DescriptionAction<({
                match: (result: RegExpMatchArray, h: any) => Object | string;
                test: RegExp;
            } & {
                [key: string]: unknown;
            })[], "Replacement handler for HTML string.">]>;
            readonly hardLineBreaks: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Add `<br>` at the position of hard line breaks, without needing spaces.">]>;
            readonly disableFormatHtml: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Disable automatic HTML format.">]>;
            readonly math: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Enable math syntax.">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly style: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "Custom stylesheet path/URL.">]>, never>;
                readonly partial: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Output markdown fragments.">]>, never>;
                readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document title (ignored in partial mode).">]>, never>;
                readonly language: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document language (ignored in partial mode).">]>, never>;
                readonly replace: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.LooseObjectSchema<{
                    readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
                    readonly match: v.SchemaWithPipe<[v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string, (result: RegExpMatchArray, h: any) => Object | string, v.BaseIssue<unknown>>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                        readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
                    }>]>;
                }, undefined>, undefined>, v.DescriptionAction<({
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                    test: RegExp;
                } & {
                    [key: string]: unknown;
                })[], "Replacement handler for HTML string.">]>, never>;
                readonly hardLineBreaks: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Add `<br>` at the position of hard line breaks, without needing spaces.">]>, never>;
                readonly disableFormatHtml: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Disable automatic HTML format.">]>, never>;
                readonly math: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Enable math syntax.">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                title?: string | undefined;
                replace?: ({
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                    test: RegExp;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                language?: string | undefined;
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }, v.BaseIssue<unknown> | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LooseObjectIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.InstanceIssue | v.BooleanIssue>;
            readonly _types?: {
                readonly input: {
                    title?: string | undefined;
                    replace?: ({
                        match: (result: RegExpMatchArray, h: any) => Object | string;
                        test: RegExp;
                    } & {
                        [key: string]: unknown;
                    })[] | undefined;
                    language?: string | undefined;
                    style?: string | string[] | undefined;
                    partial?: boolean | undefined;
                    hardLineBreaks?: boolean | undefined;
                    disableFormatHtml?: boolean | undefined;
                    math?: boolean | undefined;
                } & {
                    [key: string]: unknown;
                };
                readonly output: {
                    title?: string | undefined;
                    replace?: ({
                        match: (result: RegExpMatchArray, h: any) => Object | string;
                        test: RegExp;
                    } & {
                        [key: string]: unknown;
                    })[] | undefined;
                    language?: string | undefined;
                    style?: string | string[] | undefined;
                    partial?: boolean | undefined;
                    hardLineBreaks?: boolean | undefined;
                    disableFormatHtml?: boolean | undefined;
                    math?: boolean | undefined;
                } & {
                    [key: string]: unknown;
                };
                readonly issue: v.BaseIssue<unknown> | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LooseObjectIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.InstanceIssue | v.BooleanIssue;
            } | undefined;
        }, v.DescriptionAction<{
            title?: string | undefined;
            replace?: ({
                match: (result: RegExpMatchArray, h: any) => Object | string;
                test: RegExp;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            language?: string | undefined;
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }, "Option for convert Markdown to a stringify (HTML).">]>, never>;
        readonly image: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify a docker image to render.">]>, never>;
        readonly http: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "\n            Launch an HTTP server hosting contents instead of file protocol.\n            It is useful that requires CORS such as external web fonts.\n          ">]>, never>;
        readonly viewer: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n            Specify a URL of displaying viewer instead of vivliostyle-cli's one.\n            It is useful that using own viewer that has staging features. (ex: `https://vivliostyle.vercel.app/`)\n          ">]>, never>;
        readonly viewerParam: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "specify viewer parameters. (ex: `allowScripts=false&pixelRatio=16`)">]>, never>;
        readonly browser: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"chromium", undefined>, v.LiteralSchema<"firefox", undefined>, v.LiteralSchema<"webkit", undefined>], undefined>, v.DescriptionAction<"chromium" | "firefox" | "webkit", "\n            EXPERIMENTAL SUPPORT: Specify a browser type to launch Vivliostyle viewer.\n            Currently, Firefox and Webkit support preview command only!\n          ">]>, never>;
    };
    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
        output?: string | ({
            path: string;
        } & {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[] | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        cover?: string | ({
            src: string;
        } & {
            htmlPath?: string | boolean | undefined;
            name?: string | undefined;
        }) | undefined;
        author?: string | undefined;
        entryContext?: string | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string | string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            title?: string | undefined;
            replace?: ({
                match: (result: RegExpMatchArray, h: any) => Object | string;
                test: RegExp;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            language?: string | undefined;
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
    }, v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LooseObjectIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.InstanceIssue | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>> | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6> | v.UnionIssue<v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>>>;
    readonly _types?: {
        readonly input: {
            output?: string | ({
                path: string;
            } & {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            cover?: string | ({
                src: string;
            } & {
                htmlPath?: string | boolean | undefined;
                name?: string | undefined;
            }) | undefined;
            author?: string | undefined;
            entryContext?: string | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                title?: string | undefined;
                replace?: ({
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                    test: RegExp;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                language?: string | undefined;
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
        };
        readonly output: {
            output?: string | ({
                path: string;
            } & {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            cover?: string | ({
                src: string;
            } & {
                htmlPath?: string | boolean | undefined;
                name?: string | undefined;
            }) | undefined;
            author?: string | undefined;
            entryContext?: string | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                title?: string | undefined;
                replace?: ({
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                    test: RegExp;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                language?: string | undefined;
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
        };
        readonly issue: v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LooseObjectIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.InstanceIssue | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>> | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6> | v.UnionIssue<v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>>;
    } | undefined;
}], undefined>, v.TitleAction<{
    entry: string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | (string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | {
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    })[];
} & {
    output?: string | ({
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }) | (string | ({
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }))[] | undefined;
    title?: string | undefined;
    theme?: string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }))[] | undefined;
    cover?: string | ({
        src: string;
    } & {
        htmlPath?: string | boolean | undefined;
        name?: string | undefined;
    }) | undefined;
    author?: string | undefined;
    entryContext?: string | undefined;
    workspaceDir?: string | undefined;
    includeAssets?: string | string[] | undefined;
    copyAsset?: {
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    } | undefined;
    size?: string | undefined;
    pressReady?: boolean | undefined;
    language?: string | undefined;
    readingProgression?: "ltr" | "rtl" | undefined;
    toc?: string | boolean | {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    } | undefined;
    tocTitle?: string | undefined;
    timeout?: number | undefined;
    documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
    vfm?: ({
        title?: string | undefined;
        replace?: ({
            match: (result: RegExpMatchArray, h: any) => Object | string;
            test: RegExp;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        language?: string | undefined;
        style?: string | string[] | undefined;
        partial?: boolean | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }) | undefined;
    image?: string | undefined;
    http?: boolean | undefined;
    viewer?: string | undefined;
    viewerParam?: string | undefined;
    browser?: "chromium" | "firefox" | "webkit" | undefined;
}, "VivliostyleConfigEntry">]>, undefined>, v.MinLengthAction<({
    entry: string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | (string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | {
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    })[];
} & {
    output?: string | ({
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }) | (string | ({
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }))[] | undefined;
    title?: string | undefined;
    theme?: string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }))[] | undefined;
    cover?: string | ({
        src: string;
    } & {
        htmlPath?: string | boolean | undefined;
        name?: string | undefined;
    }) | undefined;
    author?: string | undefined;
    entryContext?: string | undefined;
    workspaceDir?: string | undefined;
    includeAssets?: string | string[] | undefined;
    copyAsset?: {
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    } | undefined;
    size?: string | undefined;
    pressReady?: boolean | undefined;
    language?: string | undefined;
    readingProgression?: "ltr" | "rtl" | undefined;
    toc?: string | boolean | {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    } | undefined;
    tocTitle?: string | undefined;
    timeout?: number | undefined;
    documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
    vfm?: ({
        title?: string | undefined;
        replace?: ({
            match: (result: RegExpMatchArray, h: any) => Object | string;
            test: RegExp;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        language?: string | undefined;
        style?: string | string[] | undefined;
        partial?: boolean | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }) | undefined;
    image?: string | undefined;
    http?: boolean | undefined;
    viewer?: string | undefined;
    viewerParam?: string | undefined;
    browser?: "chromium" | "firefox" | "webkit" | undefined;
})[], 1, "At least one config entry is required">]>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
    readonly entry: v.SchemaWithPipe<[v.UnionSchema<[v.SchemaWithPipe<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<[v.ObjectSchema<{
        readonly rel: v.LiteralSchema<"contents", undefined>;
        readonly path: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        readonly pageBreakBefore: v.SchemaWithPipe<[v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, never>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, "\n        Specify the page break position before this document.\n        It is useful when you want to specify which side a first page of the document should be placed on a two-page spread.\n      ">]>;
        readonly pageCounterReset: v.SchemaWithPipe<[v.OptionalSchema<v.SchemaWithPipe<[v.NumberSchema<undefined>, v.SafeIntegerAction<number, undefined>]>, never>, v.DescriptionAction<number | undefined, "\n        Reset the starting page number of this document by the specified integer.\n        It is useful when you want to control page numbers when including a page.\n      ">]>;
    }, undefined>, v.TitleAction<{
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    }, "ContentsEntryObject">]>, v.SchemaWithPipe<[v.ObjectSchema<{
        readonly rel: v.LiteralSchema<"cover", undefined>;
        readonly path: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        readonly imageSrc: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly imageAlt: v.OptionalSchema<v.StringSchema<undefined>, never>;
        readonly pageBreakBefore: v.SchemaWithPipe<[v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, never>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, "\n      Specify the page break position before this document.\n      It is useful when you want to specify which side a first page of the document should be placed on a two-page spread.\n    ">]>;
    }, undefined>, v.TitleAction<{
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    }, "CoverEntryObject">]>, v.SchemaWithPipe<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>>;
        readonly _types?: {
            readonly input: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            };
            readonly output: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>;
        } | undefined;
    }, v.TitleAction<{
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    }, "ArticleEntryObject">]>], undefined>], undefined>, undefined>, v.MinLengthAction<(string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | {
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    })[], 1, "At least one entry is required">]>, v.SchemaWithPipe<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
        readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>>;
        readonly _types?: {
            readonly input: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            };
            readonly output: {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>;
        } | undefined;
    }, v.TitleAction<{
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    }, "ArticleEntryObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | (string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | {
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    })[], "Entry file(s) of document.">]>;
}, undefined>, "_types" | "_run" | "entries"> & {
    readonly entries: {
        readonly entry: v.NonOptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.SchemaWithPipe<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.UnionSchema<[v.SchemaWithPipe<[v.ObjectSchema<{
            readonly rel: v.LiteralSchema<"contents", undefined>;
            readonly path: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            readonly pageBreakBefore: v.SchemaWithPipe<[v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, never>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, "\n        Specify the page break position before this document.\n        It is useful when you want to specify which side a first page of the document should be placed on a two-page spread.\n      ">]>;
            readonly pageCounterReset: v.SchemaWithPipe<[v.OptionalSchema<v.SchemaWithPipe<[v.NumberSchema<undefined>, v.SafeIntegerAction<number, undefined>]>, never>, v.DescriptionAction<number | undefined, "\n        Reset the starting page number of this document by the specified integer.\n        It is useful when you want to control page numbers when including a page.\n      ">]>;
        }, undefined>, v.TitleAction<{
            rel: "contents";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        }, "ContentsEntryObject">]>, v.SchemaWithPipe<[v.ObjectSchema<{
            readonly rel: v.LiteralSchema<"cover", undefined>;
            readonly path: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            readonly imageSrc: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly imageAlt: v.OptionalSchema<v.StringSchema<undefined>, never>;
            readonly pageBreakBefore: v.SchemaWithPipe<[v.OptionalSchema<v.UnionSchema<[v.LiteralSchema<"left", undefined>, v.LiteralSchema<"right", undefined>, v.LiteralSchema<"recto", undefined>, v.LiteralSchema<"verso", undefined>], undefined>, never>, v.DescriptionAction<"left" | "right" | "recto" | "verso" | undefined, "\n      Specify the page break position before this document.\n      It is useful when you want to specify which side a first page of the document should be placed on a two-page spread.\n    ">]>;
        }, undefined>, v.TitleAction<{
            rel: "cover";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
        }, "CoverEntryObject">]>, v.SchemaWithPipe<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
                readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
                readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
                readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly _types?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        import?: string | string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                    readonly _types?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string | string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly _types?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        import?: string | string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                    readonly _types?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string | string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
                readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
                readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>>;
            readonly _types?: {
                readonly input: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                };
                readonly output: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>;
            } | undefined;
        }, v.TitleAction<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        }, "ArticleEntryObject">]>], undefined>], undefined>, undefined>, v.MinLengthAction<(string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | {
            rel: "contents";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
        })[], 1, "At least one entry is required">]>, v.SchemaWithPipe<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>;
            readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    specifier: string;
                }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                readonly _types?: {
                    readonly input: {
                        specifier: string;
                    };
                    readonly output: {
                        specifier: string;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                } | undefined;
            }, Omit<v.ObjectSchema<{
                readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
            }, undefined>, "_types" | "_run" | "entries"> & {
                readonly entries: {
                    readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                };
                readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                    import?: string | string[] | undefined;
                }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                readonly _types?: {
                    readonly input: {
                        import?: string | string[] | undefined;
                    };
                    readonly output: {
                        import?: string | string[] | undefined;
                    };
                    readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                } | undefined;
            }], undefined>, v.TitleAction<{
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
            readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, "Missing required field: path">;
                readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
                readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
                readonly theme: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly _types?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        import?: string | string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                    readonly _types?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string | string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
                    readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        specifier: string;
                    }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
                    readonly _types?: {
                        readonly input: {
                            specifier: string;
                        };
                        readonly output: {
                            specifier: string;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
                    } | undefined;
                }, Omit<v.ObjectSchema<{
                    readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
                }, undefined>, "_types" | "_run" | "entries"> & {
                    readonly entries: {
                        readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
                    };
                    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                        import?: string | string[] | undefined;
                    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
                    readonly _types?: {
                        readonly input: {
                            import?: string | string[] | undefined;
                        };
                        readonly output: {
                            import?: string | string[] | undefined;
                        };
                        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
                    } | undefined;
                }], undefined>, v.TitleAction<{
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
                readonly encodingFormat: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, never>;
                readonly rel: v.OptionalSchema<v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>>;
            readonly _types?: {
                readonly input: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                };
                readonly output: {
                    path: string;
                    output?: string | undefined;
                    title?: string | undefined;
                    theme?: string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }) | (string | ({
                        specifier: string;
                    } & {
                        import?: string | string[] | undefined;
                    }))[] | undefined;
                    encodingFormat?: string | undefined;
                    rel?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>>;
            } | undefined;
        }, v.TitleAction<{
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        }, "ArticleEntryObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | {
            rel: "contents";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
        })[], "Entry file(s) of document.">]>, "Missing required field: entry">;
    };
    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
        entry: string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | (string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | {
            rel: "contents";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
        })[];
    }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | {
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    })[], 1> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | {
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    })[], 1>>>;
    readonly _types?: {
        readonly input: {
            entry: string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | {
                rel: "contents";
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                path?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                path?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
            })[];
        };
        readonly output: {
            entry: string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | (string | {
                path: string;
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                encodingFormat?: string | undefined;
                rel?: string | string[] | undefined;
            } | {
                rel: "contents";
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                path?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                pageCounterReset?: number | undefined;
            } | {
                rel: "cover";
                output?: string | undefined;
                title?: string | undefined;
                theme?: string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }) | (string | ({
                    specifier: string;
                } & {
                    import?: string | string[] | undefined;
                }))[] | undefined;
                path?: string | undefined;
                pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
                imageSrc?: string | undefined;
                imageAlt?: string | undefined;
            })[];
        };
        readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | {
            rel: "contents";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
        })[], 1> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.SafeIntegerIssue<number>>> | v.MinLengthIssue<(string | {
            path: string;
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            encodingFormat?: string | undefined;
            rel?: string | string[] | undefined;
        } | {
            rel: "contents";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            pageCounterReset?: number | undefined;
        } | {
            rel: "cover";
            output?: string | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            path?: string | undefined;
            pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
            imageSrc?: string | undefined;
            imageAlt?: string | undefined;
        })[], 1>>;
    } | undefined;
}, Omit<v.ObjectSchema<{
    readonly title: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Title">]>;
    readonly author: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Author">]>;
    readonly theme: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            import?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
        readonly _types?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            specifier: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                specifier: string;
            };
            readonly output: {
                specifier: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            import?: string | string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
        readonly _types?: {
            readonly input: {
                import?: string | string[] | undefined;
            };
            readonly output: {
                import?: string | string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }))[], "Theme package path(s) or URL(s) of css file.">]>;
    readonly entryContext: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Directory of referencing entry file(s).">]>;
    readonly output: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>, "Missing required field: path">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            path: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                path: string;
            };
            readonly output: {
                path: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly format: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>;
        readonly renderMode: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>;
        readonly preflight: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>;
        readonly preflightOption: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly format: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>, never>;
            readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>, never>;
            readonly preflight: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>, never>;
            readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
        readonly _types?: {
            readonly input: {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly output: {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }, "OutputObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly path: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>, "Missing required field: path">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            path: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                path: string;
            };
            readonly output: {
                path: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly format: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>;
        readonly renderMode: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>;
        readonly preflight: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>;
        readonly preflightOption: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly format: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>, never>;
            readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>, never>;
            readonly preflight: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>, never>;
            readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
        readonly _types?: {
            readonly input: {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly output: {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
        } | undefined;
    }], undefined>, v.TitleAction<{
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }, "OutputObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | ({
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }) | (string | ({
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }))[], "Options about outputs.">]>;
    readonly workspaceDir: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n            Specify the directory where the intermediate files (manuscript HTMLs, publication.json, etc.) are saved.\n            If not specified, theses files are saved in the same directory as the input file.\n          ">]>;
    /** @deprecated */
    readonly includeAssets: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.MetadataAction<string | string[], {
        readonly deprecated: true;
    }>, v.DescriptionAction<string | string[], "Use `copyAsset.includes` instead">]>;
    readonly copyAsset: v.SchemaWithPipe<[Omit<v.ObjectSchema<{
        readonly includes: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to include as asset files.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>;
        readonly excludes: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to exclude from the asset file.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>;
        readonly includeFileExtensions: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to include as an asset file. (default: `[png, jpg, jpeg, svg, gif, webp, apng, ttf, otf, woff, woff2]`)">]>;
        readonly excludeFileExtensions: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to exclude as an asset file.">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly includes: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to include as asset files.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>, never>;
            readonly excludes: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to exclude from the asset file.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>, never>;
            readonly includeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to include as an asset file. (default: `[png, jpg, jpeg, svg, gif, webp, apng, ttf, otf, woff, woff2]`)">]>, never>;
            readonly excludeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to exclude as an asset file.">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
        readonly _types?: {
            readonly input: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            };
            readonly output: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>;
        } | undefined;
    }, v.DescriptionAction<{
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    }, "Options about asset files to be copied when exporting output.">]>;
    readonly size: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n            Output pdf size. (default: `letter`)\n            - preset: `A5`, `A4`, `A3`, `B5`, `B4`, `JIS-B5`, `JIS-B4`, `letter`, `legal`, `ledger`\n            - custom(comma separated): `182mm,257mm` or `8.5in,11in`\n          ">]>;
    readonly pressReady: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "\n            Make generated PDF compatible with press ready PDF/X-1a. (default: `false`)\n            This option is equivalent with `\"preflight\": \"press-ready\"`\n          ">]>;
    readonly language: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Language">]>;
    readonly readingProgression: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"ltr", undefined>, v.LiteralSchema<"rtl", undefined>], undefined>, v.DescriptionAction<"ltr" | "rtl", "Specify the reading progression of the document. This is typically determined automatically by the CSS writing-mode, so use this option only if you need to set it explicitly.">]>;
    readonly toc: v.SchemaWithPipe<[v.UnionSchema<[Omit<v.ObjectSchema<{
        readonly title: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the title of the generated ToC document.">]>;
        readonly htmlPath: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the location where the generated ToC document will be saved. (default: `index.html`)">]>;
        readonly sectionDepth: v.SchemaWithPipe<[v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, "Specify the depth of the section to be included in the ToC document. (default: `0`)">]>;
        readonly transformDocumentList: v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, (nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, {
            readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
            readonly typeReferences: readonly [v.GenericSchema<StructuredDocument, StructuredDocument, v.BaseIssue<unknown>>];
        }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any, "Specify the transform function for the document list.">]>;
        readonly transformSectionList: v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, (nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, {
            readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
            readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection, StructuredDocumentSection, v.BaseIssue<unknown>>];
        }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any, "Specify the transform function for the section list.">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the title of the generated ToC document.">]>, never>;
            readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the location where the generated ToC document will be saved. (default: `index.html`)">]>, never>;
            readonly sectionDepth: v.OptionalSchema<v.SchemaWithPipe<[v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, "Specify the depth of the section to be included in the ToC document. (default: `0`)">]>, never>;
            readonly transformDocumentList: v.OptionalSchema<v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, (nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocument, StructuredDocument, v.BaseIssue<unknown>>];
            }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, "Specify the transform function for the document list.">]>, never>;
            readonly transformSectionList: v.OptionalSchema<v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, (nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection, StructuredDocumentSection, v.BaseIssue<unknown>>];
            }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, "Specify the transform function for the section list.">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }, v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>>;
        readonly _types?: {
            readonly input: {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            };
            readonly output: {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            };
            readonly issue: v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>;
        } | undefined;
    }, v.BooleanSchema<undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean | {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    }, "Options about Table of Contents (ToC) documents.">]>;
    /** @deprecated */
    readonly tocTitle: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.MetadataAction<string, {
        readonly deprecated: true;
    }>, v.DescriptionAction<string, "Use `toc.title` instead">]>;
    readonly cover: v.SchemaWithPipe<[v.UnionSchema<[v.IntersectSchema<[Omit<v.ObjectSchema<{
        readonly src: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the cover image to be used for the cover page.">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly src: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the cover image to be used for the cover page.">]>, "Missing required field: src">;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            src: string;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
        readonly _types?: {
            readonly input: {
                src: string;
            };
            readonly output: {
                src: string;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
        } | undefined;
    }, Omit<v.ObjectSchema<{
        readonly name: v.SchemaWithPipe<[v.StringSchema<undefined>, v.DescriptionAction<string, "Specify alternative text for the cover image.">]>;
        readonly htmlPath: v.SchemaWithPipe<[v.UnionSchema<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, "\n                      Specify the location where the generated cover document will be saved. (default: cover.html)\n                      If falsy value is set, the cover document won't be generated.\n                    ">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly name: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.DescriptionAction<string, "Specify alternative text for the cover image.">]>, never>;
            readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, "\n                      Specify the location where the generated cover document will be saved. (default: cover.html)\n                      If falsy value is set, the cover document won't be generated.\n                    ">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            htmlPath?: string | boolean | undefined;
            name?: string | undefined;
        }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>>;
        readonly _types?: {
            readonly input: {
                htmlPath?: string | boolean | undefined;
                name?: string | undefined;
            };
            readonly output: {
                htmlPath?: string | boolean | undefined;
                name?: string | undefined;
            };
            readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>;
        } | undefined;
    }], undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | ({
        src: string;
    } & {
        htmlPath?: string | boolean | undefined;
        name?: string | undefined;
    }), "Options about cover images and cover page documents.">]>;
    readonly timeout: v.SchemaWithPipe<[v.NumberSchema<undefined>, v.DescriptionAction<number, "Timeout limit for waiting Vivliostyle process (ms). (default: `120000`)">]>;
    readonly documentProcessor: v.SchemaWithPipe<[v.GenericSchema<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, (option: StringifyMarkdownOptions, metadata: Metadata) => Processor, v.BaseIssue<unknown>>, v.MetadataAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, {
        readonly typeString: "(option: import(\"@vivliostyle/vfm\").StringifyMarkdownOptions, metadata: import(\"@vivliostyle/vfm\").Metadata) => import(\"unified\").Processor";
    }>, v.DescriptionAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, "Custom function to provide unified Processor from markdown into html">]>;
    readonly vfm: v.SchemaWithPipe<[Omit<v.LooseObjectSchema<{
        readonly style: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "Custom stylesheet path/URL.">]>;
        readonly partial: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Output markdown fragments.">]>;
        readonly title: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document title (ignored in partial mode).">]>;
        readonly language: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document language (ignored in partial mode).">]>;
        readonly replace: v.SchemaWithPipe<[v.ArraySchema<v.LooseObjectSchema<{
            readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
            readonly match: v.SchemaWithPipe<[v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string, (result: RegExpMatchArray, h: any) => Object | string, v.BaseIssue<unknown>>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
            }>]>;
        }, undefined>, undefined>, v.DescriptionAction<({
            match: (result: RegExpMatchArray, h: any) => Object | string;
            test: RegExp;
        } & {
            [key: string]: unknown;
        })[], "Replacement handler for HTML string.">]>;
        readonly hardLineBreaks: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Add `<br>` at the position of hard line breaks, without needing spaces.">]>;
        readonly disableFormatHtml: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Disable automatic HTML format.">]>;
        readonly math: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Enable math syntax.">]>;
    }, undefined>, "_types" | "_run" | "entries"> & {
        readonly entries: {
            readonly style: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "Custom stylesheet path/URL.">]>, never>;
            readonly partial: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Output markdown fragments.">]>, never>;
            readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document title (ignored in partial mode).">]>, never>;
            readonly language: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document language (ignored in partial mode).">]>, never>;
            readonly replace: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.LooseObjectSchema<{
                readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
                readonly match: v.SchemaWithPipe<[v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string, (result: RegExpMatchArray, h: any) => Object | string, v.BaseIssue<unknown>>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                    readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
                }>]>;
            }, undefined>, undefined>, v.DescriptionAction<({
                match: (result: RegExpMatchArray, h: any) => Object | string;
                test: RegExp;
            } & {
                [key: string]: unknown;
            })[], "Replacement handler for HTML string.">]>, never>;
            readonly hardLineBreaks: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Add `<br>` at the position of hard line breaks, without needing spaces.">]>, never>;
            readonly disableFormatHtml: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Disable automatic HTML format.">]>, never>;
            readonly math: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Enable math syntax.">]>, never>;
        };
        readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
            title?: string | undefined;
            replace?: ({
                match: (result: RegExpMatchArray, h: any) => Object | string;
                test: RegExp;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            language?: string | undefined;
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }, v.BaseIssue<unknown> | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LooseObjectIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.InstanceIssue | v.BooleanIssue>;
        readonly _types?: {
            readonly input: {
                title?: string | undefined;
                replace?: ({
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                    test: RegExp;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                language?: string | undefined;
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            };
            readonly output: {
                title?: string | undefined;
                replace?: ({
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                    test: RegExp;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                language?: string | undefined;
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            };
            readonly issue: v.BaseIssue<unknown> | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LooseObjectIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.InstanceIssue | v.BooleanIssue;
        } | undefined;
    }, v.DescriptionAction<{
        title?: string | undefined;
        replace?: ({
            match: (result: RegExpMatchArray, h: any) => Object | string;
            test: RegExp;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        language?: string | undefined;
        style?: string | string[] | undefined;
        partial?: boolean | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }, "Option for convert Markdown to a stringify (HTML).">]>;
    readonly image: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify a docker image to render.">]>;
    readonly http: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "\n            Launch an HTTP server hosting contents instead of file protocol.\n            It is useful that requires CORS such as external web fonts.\n          ">]>;
    readonly viewer: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n            Specify a URL of displaying viewer instead of vivliostyle-cli's one.\n            It is useful that using own viewer that has staging features. (ex: `https://vivliostyle.vercel.app/`)\n          ">]>;
    readonly viewerParam: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "specify viewer parameters. (ex: `allowScripts=false&pixelRatio=16`)">]>;
    readonly browser: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"chromium", undefined>, v.LiteralSchema<"firefox", undefined>, v.LiteralSchema<"webkit", undefined>], undefined>, v.DescriptionAction<"chromium" | "firefox" | "webkit", "\n            EXPERIMENTAL SUPPORT: Specify a browser type to launch Vivliostyle viewer.\n            Currently, Firefox and Webkit support preview command only!\n          ">]>;
}, undefined>, "_types" | "_run" | "entries"> & {
    readonly entries: {
        readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Title">]>, never>;
        readonly author: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Author">]>, never>;
        readonly theme: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly specifier: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly specifier: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n          Specifier name of importing theme package or a path of CSS file.\n          - A npm-style package argument is allowed (ex: `@vivliostyle/theme-academic@1` `./local-pkg`)\n          - A URL or a local path of CSS is allowed (ex: `./style.css`, `https://example.com/style.css`)\n        ">]>, "Missing required field: specifier">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                specifier: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    specifier: string;
                };
                readonly output: {
                    specifier: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly import: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly import: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "\n          Importing CSS path(s) of the package.\n          Specify this if you want to import other than the default file.\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                import?: string | string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>;
            readonly _types?: {
                readonly input: {
                    import?: string | string[] | undefined;
                };
                readonly output: {
                    import?: string | string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }, "ThemeObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[], "Theme package path(s) or URL(s) of css file.">]>, never>;
        readonly entryContext: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Directory of referencing entry file(s).">]>, never>;
        readonly output: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.UnionSchema<[v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>, "Missing required field: path">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                path: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    path: string;
                };
                readonly output: {
                    path: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly format: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>;
            readonly renderMode: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>;
            readonly preflight: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>;
            readonly preflightOption: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly format: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>, never>;
                readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>, never>;
                readonly preflight: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>, never>;
                readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
            readonly _types?: {
                readonly input: {
                    format?: string | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly output: {
                    format?: string | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            path: string;
        } & {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, "OutputObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, undefined>, v.SchemaWithPipe<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly path: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly path: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output file name or directory [`<title>.pdf`].">]>, "Missing required field: path">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                path: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    path: string;
                };
                readonly output: {
                    path: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly format: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>;
            readonly renderMode: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>;
            readonly preflight: v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>;
            readonly preflightOption: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly format: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify output format.">]>, never>;
                readonly renderMode: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"local", undefined>, v.LiteralSchema<"docker", undefined>], undefined>, v.DescriptionAction<"local" | "docker", "if `docker` is set, Vivliostyle try to render PDF on Docker container [`local`].">]>, never>;
                readonly preflight: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"press-ready", undefined>, v.LiteralSchema<"press-ready-local", undefined>], undefined>, v.DescriptionAction<"press-ready" | "press-ready-local", "Apply the process to generate PDF for printing.">]>, never>;
                readonly preflightOption: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n          Options for preflight process (ex: `gray-scale`, `enforce-outline`).\n          Please refer the document of press-ready for further information. https://github.com/vibranthq/press-ready\n        ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>;
            readonly _types?: {
                readonly input: {
                    format?: string | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly output: {
                    format?: string | undefined;
                    renderMode?: "local" | "docker" | undefined;
                    preflight?: "press-ready" | "press-ready-local" | undefined;
                    preflightOption?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>;
            } | undefined;
        }], undefined>, v.TitleAction<{
            path: string;
        } & {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }, "OutputObject">]>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | ({
            path: string;
        } & {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[], "Options about outputs.">]>, never>;
        readonly workspaceDir: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n            Specify the directory where the intermediate files (manuscript HTMLs, publication.json, etc.) are saved.\n            If not specified, theses files are saved in the same directory as the input file.\n          ">]>, never>;
        readonly includeAssets: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.MetadataAction<string | string[], {
            readonly deprecated: true;
        }>, v.DescriptionAction<string | string[], "Use `copyAsset.includes` instead">]>, never>;
        readonly copyAsset: v.OptionalSchema<v.SchemaWithPipe<[Omit<v.ObjectSchema<{
            readonly includes: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to include as asset files.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>;
            readonly excludes: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to exclude from the asset file.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>;
            readonly includeFileExtensions: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to include as an asset file. (default: `[png, jpg, jpeg, svg, gif, webp, apng, ttf, otf, woff, woff2]`)">]>;
            readonly excludeFileExtensions: v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to exclude as an asset file.">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly includes: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to include as asset files.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>, never>;
                readonly excludes: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "\n                  Specify directories and files you want to exclude from the asset file.\n                  This option supports wildcard characters to make glob patterns.\n                ">]>, never>;
                readonly includeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to include as an asset file. (default: `[png, jpg, jpeg, svg, gif, webp, apng, ttf, otf, woff, woff2]`)">]>, never>;
                readonly excludeFileExtensions: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.DescriptionAction<string[], "Specify extensions of the file you want to exclude as an asset file.">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            }, v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>;
            readonly _types?: {
                readonly input: {
                    includes?: string[] | undefined;
                    excludes?: string[] | undefined;
                    includeFileExtensions?: string[] | undefined;
                    excludeFileExtensions?: string[] | undefined;
                };
                readonly output: {
                    includes?: string[] | undefined;
                    excludes?: string[] | undefined;
                    includeFileExtensions?: string[] | undefined;
                    excludeFileExtensions?: string[] | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>;
            } | undefined;
        }, v.DescriptionAction<{
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        }, "Options about asset files to be copied when exporting output.">]>, never>;
        readonly size: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n            Output pdf size. (default: `letter`)\n            - preset: `A5`, `A4`, `A3`, `B5`, `B4`, `JIS-B5`, `JIS-B4`, `letter`, `legal`, `ledger`\n            - custom(comma separated): `182mm,257mm` or `8.5in,11in`\n          ">]>, never>;
        readonly pressReady: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "\n            Make generated PDF compatible with press ready PDF/X-1a. (default: `false`)\n            This option is equivalent with `\"preflight\": \"press-ready\"`\n          ">]>, never>;
        readonly language: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Language">]>, never>;
        readonly readingProgression: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"ltr", undefined>, v.LiteralSchema<"rtl", undefined>], undefined>, v.DescriptionAction<"ltr" | "rtl", "Specify the reading progression of the document. This is typically determined automatically by the CSS writing-mode, so use this option only if you need to set it explicitly.">]>, never>;
        readonly toc: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[Omit<v.ObjectSchema<{
            readonly title: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the title of the generated ToC document.">]>;
            readonly htmlPath: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the location where the generated ToC document will be saved. (default: `index.html`)">]>;
            readonly sectionDepth: v.SchemaWithPipe<[v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, "Specify the depth of the section to be included in the ToC document. (default: `0`)">]>;
            readonly transformDocumentList: v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, (nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocument, StructuredDocument, v.BaseIssue<unknown>>];
            }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any, "Specify the transform function for the document list.">]>;
            readonly transformSectionList: v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, (nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, {
                readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
                readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection, StructuredDocumentSection, v.BaseIssue<unknown>>];
            }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any, "Specify the transform function for the section list.">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the title of the generated ToC document.">]>, never>;
                readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the location where the generated ToC document will be saved. (default: `index.html`)">]>, never>;
                readonly sectionDepth: v.OptionalSchema<v.SchemaWithPipe<[v.NumberSchema<undefined>, v.IntegerAction<number, undefined>, v.MinValueAction<number, 0, undefined>, v.MaxValueAction<number, 6, undefined>, v.DescriptionAction<number, "Specify the depth of the section to be included in the ToC document. (default: `0`)">]>, never>;
                readonly transformDocumentList: v.OptionalSchema<v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any, (nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any, {
                    readonly typeString: "(nodeList: StructuredDocument[]) => (propsList: { children: any }[]) => any";
                    readonly typeReferences: readonly [v.GenericSchema<StructuredDocument, StructuredDocument, v.BaseIssue<unknown>>];
                }>, v.DescriptionAction<(nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any, "Specify the transform function for the document list.">]>, never>;
                readonly transformSectionList: v.OptionalSchema<v.SchemaWithPipe<[v.GenericSchema<(nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any, (nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any, v.BaseIssue<unknown>>, v.MetadataAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any, {
                    readonly typeString: "(nodeList: StructuredDocumentSection[]) => (propsList: { children: any }[]) => any";
                    readonly typeReferences: readonly [v.GenericSchema<StructuredDocumentSection, StructuredDocumentSection, v.BaseIssue<unknown>>];
                }>, v.DescriptionAction<(nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any, "Specify the transform function for the section list.">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            }, v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>>;
            readonly _types?: {
                readonly input: {
                    title?: string | undefined;
                    htmlPath?: string | undefined;
                    sectionDepth?: number | undefined;
                    transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                    transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                };
                readonly output: {
                    title?: string | undefined;
                    htmlPath?: string | undefined;
                    sectionDepth?: number | undefined;
                    transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                    transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                        children: any;
                    }[]) => any) | undefined;
                };
                readonly issue: v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>;
            } | undefined;
        }, v.BooleanSchema<undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        }, "Options about Table of Contents (ToC) documents.">]>, never>;
        readonly tocTitle: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.MetadataAction<string, {
            readonly deprecated: true;
        }>, v.DescriptionAction<string, "Use `toc.title` instead">]>, never>;
        readonly cover: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.IntersectSchema<[Omit<v.ObjectSchema<{
            readonly src: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the cover image to be used for the cover page.">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly src: v.NonOptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify the cover image to be used for the cover page.">]>, "Missing required field: src">;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                src: string;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue>;
            readonly _types?: {
                readonly input: {
                    src: string;
                };
                readonly output: {
                    src: string;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.NonOptionalIssue;
            } | undefined;
        }, Omit<v.ObjectSchema<{
            readonly name: v.SchemaWithPipe<[v.StringSchema<undefined>, v.DescriptionAction<string, "Specify alternative text for the cover image.">]>;
            readonly htmlPath: v.SchemaWithPipe<[v.UnionSchema<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, "\n                      Specify the location where the generated cover document will be saved. (default: cover.html)\n                      If falsy value is set, the cover document won't be generated.\n                    ">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly name: v.OptionalSchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.DescriptionAction<string, "Specify alternative text for the cover image.">]>, never>;
                readonly htmlPath: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.BooleanSchema<undefined>], undefined>, v.DescriptionAction<string | boolean, "\n                      Specify the location where the generated cover document will be saved. (default: cover.html)\n                      If falsy value is set, the cover document won't be generated.\n                    ">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                htmlPath?: string | boolean | undefined;
                name?: string | undefined;
            }, v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>>;
            readonly _types?: {
                readonly input: {
                    htmlPath?: string | boolean | undefined;
                    name?: string | undefined;
                };
                readonly output: {
                    htmlPath?: string | boolean | undefined;
                    name?: string | undefined;
                };
                readonly issue: v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>;
            } | undefined;
        }], undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | ({
            src: string;
        } & {
            htmlPath?: string | boolean | undefined;
            name?: string | undefined;
        }), "Options about cover images and cover page documents.">]>, never>;
        readonly timeout: v.OptionalSchema<v.SchemaWithPipe<[v.NumberSchema<undefined>, v.DescriptionAction<number, "Timeout limit for waiting Vivliostyle process (ms). (default: `120000`)">]>, never>;
        readonly documentProcessor: v.OptionalSchema<v.SchemaWithPipe<[v.GenericSchema<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, (option: StringifyMarkdownOptions, metadata: Metadata) => Processor, v.BaseIssue<unknown>>, v.MetadataAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, {
            readonly typeString: "(option: import(\"@vivliostyle/vfm\").StringifyMarkdownOptions, metadata: import(\"@vivliostyle/vfm\").Metadata) => import(\"unified\").Processor";
        }>, v.DescriptionAction<(option: StringifyMarkdownOptions, metadata: Metadata) => Processor, "Custom function to provide unified Processor from markdown into html">]>, never>;
        readonly vfm: v.OptionalSchema<v.SchemaWithPipe<[Omit<v.LooseObjectSchema<{
            readonly style: v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "Custom stylesheet path/URL.">]>;
            readonly partial: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Output markdown fragments.">]>;
            readonly title: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document title (ignored in partial mode).">]>;
            readonly language: v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document language (ignored in partial mode).">]>;
            readonly replace: v.SchemaWithPipe<[v.ArraySchema<v.LooseObjectSchema<{
                readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
                readonly match: v.SchemaWithPipe<[v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string, (result: RegExpMatchArray, h: any) => Object | string, v.BaseIssue<unknown>>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                    readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
                }>]>;
            }, undefined>, undefined>, v.DescriptionAction<({
                match: (result: RegExpMatchArray, h: any) => Object | string;
                test: RegExp;
            } & {
                [key: string]: unknown;
            })[], "Replacement handler for HTML string.">]>;
            readonly hardLineBreaks: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Add `<br>` at the position of hard line breaks, without needing spaces.">]>;
            readonly disableFormatHtml: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Disable automatic HTML format.">]>;
            readonly math: v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Enable math syntax.">]>;
        }, undefined>, "_types" | "_run" | "entries"> & {
            readonly entries: {
                readonly style: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.ArraySchema<v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, undefined>, v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>], undefined>, v.DescriptionAction<string | string[], "Custom stylesheet path/URL.">]>, never>;
                readonly partial: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Output markdown fragments.">]>, never>;
                readonly title: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document title (ignored in partial mode).">]>, never>;
                readonly language: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Document language (ignored in partial mode).">]>, never>;
                readonly replace: v.OptionalSchema<v.SchemaWithPipe<[v.ArraySchema<v.LooseObjectSchema<{
                    readonly test: v.InstanceSchema<RegExpConstructor, undefined>;
                    readonly match: v.SchemaWithPipe<[v.GenericSchema<(result: RegExpMatchArray, h: any) => Object | string, (result: RegExpMatchArray, h: any) => Object | string, v.BaseIssue<unknown>>, v.MetadataAction<(result: RegExpMatchArray, h: any) => Object | string, {
                        readonly typeString: "(result: RegExpMatchArray, h: any) => Object | string";
                    }>]>;
                }, undefined>, undefined>, v.DescriptionAction<({
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                    test: RegExp;
                } & {
                    [key: string]: unknown;
                })[], "Replacement handler for HTML string.">]>, never>;
                readonly hardLineBreaks: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Add `<br>` at the position of hard line breaks, without needing spaces.">]>, never>;
                readonly disableFormatHtml: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Disable automatic HTML format.">]>, never>;
                readonly math: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "Enable math syntax.">]>, never>;
            };
            readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
                title?: string | undefined;
                replace?: ({
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                    test: RegExp;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                language?: string | undefined;
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }, v.BaseIssue<unknown> | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LooseObjectIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.InstanceIssue | v.BooleanIssue>;
            readonly _types?: {
                readonly input: {
                    title?: string | undefined;
                    replace?: ({
                        match: (result: RegExpMatchArray, h: any) => Object | string;
                        test: RegExp;
                    } & {
                        [key: string]: unknown;
                    })[] | undefined;
                    language?: string | undefined;
                    style?: string | string[] | undefined;
                    partial?: boolean | undefined;
                    hardLineBreaks?: boolean | undefined;
                    disableFormatHtml?: boolean | undefined;
                    math?: boolean | undefined;
                } & {
                    [key: string]: unknown;
                };
                readonly output: {
                    title?: string | undefined;
                    replace?: ({
                        match: (result: RegExpMatchArray, h: any) => Object | string;
                        test: RegExp;
                    } & {
                        [key: string]: unknown;
                    })[] | undefined;
                    language?: string | undefined;
                    style?: string | string[] | undefined;
                    partial?: boolean | undefined;
                    hardLineBreaks?: boolean | undefined;
                    disableFormatHtml?: boolean | undefined;
                    math?: boolean | undefined;
                } & {
                    [key: string]: unknown;
                };
                readonly issue: v.BaseIssue<unknown> | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.LooseObjectIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.InstanceIssue | v.BooleanIssue;
            } | undefined;
        }, v.DescriptionAction<{
            title?: string | undefined;
            replace?: ({
                match: (result: RegExpMatchArray, h: any) => Object | string;
                test: RegExp;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            language?: string | undefined;
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }, "Option for convert Markdown to a stringify (HTML).">]>, never>;
        readonly image: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "Specify a docker image to render.">]>, never>;
        readonly http: v.OptionalSchema<v.SchemaWithPipe<[v.BooleanSchema<undefined>, v.DescriptionAction<boolean, "\n            Launch an HTTP server hosting contents instead of file protocol.\n            It is useful that requires CORS such as external web fonts.\n          ">]>, never>;
        readonly viewer: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "\n            Specify a URL of displaying viewer instead of vivliostyle-cli's one.\n            It is useful that using own viewer that has staging features. (ex: `https://vivliostyle.vercel.app/`)\n          ">]>, never>;
        readonly viewerParam: v.OptionalSchema<v.SchemaWithPipe<[v.SchemaWithPipe<[v.StringSchema<undefined>, v.TrimAction, v.MinLengthAction<string, 1, "At least one character is required">]>, v.DescriptionAction<string, "specify viewer parameters. (ex: `allowScripts=false&pixelRatio=16`)">]>, never>;
        readonly browser: v.OptionalSchema<v.SchemaWithPipe<[v.UnionSchema<[v.LiteralSchema<"chromium", undefined>, v.LiteralSchema<"firefox", undefined>, v.LiteralSchema<"webkit", undefined>], undefined>, v.DescriptionAction<"chromium" | "firefox" | "webkit", "\n            EXPERIMENTAL SUPPORT: Specify a browser type to launch Vivliostyle viewer.\n            Currently, Firefox and Webkit support preview command only!\n          ">]>, never>;
    };
    readonly _run: (dataset: v.Dataset<unknown, never>, config: v.Config<v.BaseIssue<unknown>>) => v.Dataset<{
        output?: string | ({
            path: string;
        } & {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }) | (string | ({
            path: string;
        } & {
            format?: string | undefined;
            renderMode?: "local" | "docker" | undefined;
            preflight?: "press-ready" | "press-ready-local" | undefined;
            preflightOption?: string[] | undefined;
        }))[] | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        cover?: string | ({
            src: string;
        } & {
            htmlPath?: string | boolean | undefined;
            name?: string | undefined;
        }) | undefined;
        author?: string | undefined;
        entryContext?: string | undefined;
        workspaceDir?: string | undefined;
        includeAssets?: string | string[] | undefined;
        copyAsset?: {
            includes?: string[] | undefined;
            excludes?: string[] | undefined;
            includeFileExtensions?: string[] | undefined;
            excludeFileExtensions?: string[] | undefined;
        } | undefined;
        size?: string | undefined;
        pressReady?: boolean | undefined;
        language?: string | undefined;
        readingProgression?: "ltr" | "rtl" | undefined;
        toc?: string | boolean | {
            title?: string | undefined;
            htmlPath?: string | undefined;
            sectionDepth?: number | undefined;
            transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
            transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                children: any;
            }[]) => any) | undefined;
        } | undefined;
        tocTitle?: string | undefined;
        timeout?: number | undefined;
        documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
        vfm?: ({
            title?: string | undefined;
            replace?: ({
                match: (result: RegExpMatchArray, h: any) => Object | string;
                test: RegExp;
            } & {
                [key: string]: unknown;
            })[] | undefined;
            language?: string | undefined;
            style?: string | string[] | undefined;
            partial?: boolean | undefined;
            hardLineBreaks?: boolean | undefined;
            disableFormatHtml?: boolean | undefined;
            math?: boolean | undefined;
        } & {
            [key: string]: unknown;
        }) | undefined;
        image?: string | undefined;
        http?: boolean | undefined;
        viewer?: string | undefined;
        viewerParam?: string | undefined;
        browser?: "chromium" | "firefox" | "webkit" | undefined;
    }, v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LooseObjectIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.InstanceIssue | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>> | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6> | v.UnionIssue<v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>>>;
    readonly _types?: {
        readonly input: {
            output?: string | ({
                path: string;
            } & {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            cover?: string | ({
                src: string;
            } & {
                htmlPath?: string | boolean | undefined;
                name?: string | undefined;
            }) | undefined;
            author?: string | undefined;
            entryContext?: string | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                title?: string | undefined;
                replace?: ({
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                    test: RegExp;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                language?: string | undefined;
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
        };
        readonly output: {
            output?: string | ({
                path: string;
            } & {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }) | (string | ({
                path: string;
            } & {
                format?: string | undefined;
                renderMode?: "local" | "docker" | undefined;
                preflight?: "press-ready" | "press-ready-local" | undefined;
                preflightOption?: string[] | undefined;
            }))[] | undefined;
            title?: string | undefined;
            theme?: string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }) | (string | ({
                specifier: string;
            } & {
                import?: string | string[] | undefined;
            }))[] | undefined;
            cover?: string | ({
                src: string;
            } & {
                htmlPath?: string | boolean | undefined;
                name?: string | undefined;
            }) | undefined;
            author?: string | undefined;
            entryContext?: string | undefined;
            workspaceDir?: string | undefined;
            includeAssets?: string | string[] | undefined;
            copyAsset?: {
                includes?: string[] | undefined;
                excludes?: string[] | undefined;
                includeFileExtensions?: string[] | undefined;
                excludeFileExtensions?: string[] | undefined;
            } | undefined;
            size?: string | undefined;
            pressReady?: boolean | undefined;
            language?: string | undefined;
            readingProgression?: "ltr" | "rtl" | undefined;
            toc?: string | boolean | {
                title?: string | undefined;
                htmlPath?: string | undefined;
                sectionDepth?: number | undefined;
                transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
                transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
                    children: any;
                }[]) => any) | undefined;
            } | undefined;
            tocTitle?: string | undefined;
            timeout?: number | undefined;
            documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
            vfm?: ({
                title?: string | undefined;
                replace?: ({
                    match: (result: RegExpMatchArray, h: any) => Object | string;
                    test: RegExp;
                } & {
                    [key: string]: unknown;
                })[] | undefined;
                language?: string | undefined;
                style?: string | string[] | undefined;
                partial?: boolean | undefined;
                hardLineBreaks?: boolean | undefined;
                disableFormatHtml?: boolean | undefined;
                math?: boolean | undefined;
            } & {
                [key: string]: unknown;
            }) | undefined;
            image?: string | undefined;
            http?: boolean | undefined;
            viewer?: string | undefined;
            viewerParam?: string | undefined;
            browser?: "chromium" | "firefox" | "webkit" | undefined;
        };
        readonly issue: v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LooseObjectIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.UnionIssue<v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1>>>> | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.InstanceIssue | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.ArrayIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.LiteralIssue | v.UnionIssue<v.LiteralIssue>>> | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6> | v.UnionIssue<v.BaseIssue<unknown> | v.ObjectIssue | v.StringIssue | v.NumberIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue | v.IntegerIssue<number> | v.MinValueIssue<number, 0> | v.MaxValueIssue<number, 6>> | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue> | v.UnionIssue<v.ObjectIssue | v.StringIssue | v.MinLengthIssue<string, 1> | v.IntersectIssue | v.NonOptionalIssue | v.BooleanIssue | v.UnionIssue<v.StringIssue | v.MinLengthIssue<string, 1> | v.BooleanIssue>>;
    } | undefined;
}], undefined>, v.TitleAction<{
    entry: string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | (string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | {
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    })[];
} & {
    output?: string | ({
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }) | (string | ({
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }))[] | undefined;
    title?: string | undefined;
    theme?: string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }))[] | undefined;
    cover?: string | ({
        src: string;
    } & {
        htmlPath?: string | boolean | undefined;
        name?: string | undefined;
    }) | undefined;
    author?: string | undefined;
    entryContext?: string | undefined;
    workspaceDir?: string | undefined;
    includeAssets?: string | string[] | undefined;
    copyAsset?: {
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    } | undefined;
    size?: string | undefined;
    pressReady?: boolean | undefined;
    language?: string | undefined;
    readingProgression?: "ltr" | "rtl" | undefined;
    toc?: string | boolean | {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    } | undefined;
    tocTitle?: string | undefined;
    timeout?: number | undefined;
    documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
    vfm?: ({
        title?: string | undefined;
        replace?: ({
            match: (result: RegExpMatchArray, h: any) => Object | string;
            test: RegExp;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        language?: string | undefined;
        style?: string | string[] | undefined;
        partial?: boolean | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }) | undefined;
    image?: string | undefined;
    http?: boolean | undefined;
    viewer?: string | undefined;
    viewerParam?: string | undefined;
    browser?: "chromium" | "firefox" | "webkit" | undefined;
}, "VivliostyleConfigEntry">]>], undefined>, v.TitleAction<({
    entry: string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | (string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | {
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    })[];
} & {
    output?: string | ({
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }) | (string | ({
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }))[] | undefined;
    title?: string | undefined;
    theme?: string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }))[] | undefined;
    cover?: string | ({
        src: string;
    } & {
        htmlPath?: string | boolean | undefined;
        name?: string | undefined;
    }) | undefined;
    author?: string | undefined;
    entryContext?: string | undefined;
    workspaceDir?: string | undefined;
    includeAssets?: string | string[] | undefined;
    copyAsset?: {
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    } | undefined;
    size?: string | undefined;
    pressReady?: boolean | undefined;
    language?: string | undefined;
    readingProgression?: "ltr" | "rtl" | undefined;
    toc?: string | boolean | {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    } | undefined;
    tocTitle?: string | undefined;
    timeout?: number | undefined;
    documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
    vfm?: ({
        title?: string | undefined;
        replace?: ({
            match: (result: RegExpMatchArray, h: any) => Object | string;
            test: RegExp;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        language?: string | undefined;
        style?: string | string[] | undefined;
        partial?: boolean | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }) | undefined;
    image?: string | undefined;
    http?: boolean | undefined;
    viewer?: string | undefined;
    viewerParam?: string | undefined;
    browser?: "chromium" | "firefox" | "webkit" | undefined;
}) | ({
    entry: string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | (string | {
        path: string;
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        encodingFormat?: string | undefined;
        rel?: string | string[] | undefined;
    } | {
        rel: "contents";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        pageCounterReset?: number | undefined;
    } | {
        rel: "cover";
        output?: string | undefined;
        title?: string | undefined;
        theme?: string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }) | (string | ({
            specifier: string;
        } & {
            import?: string | string[] | undefined;
        }))[] | undefined;
        path?: string | undefined;
        pageBreakBefore?: "left" | "right" | "recto" | "verso" | undefined;
        imageSrc?: string | undefined;
        imageAlt?: string | undefined;
    })[];
} & {
    output?: string | ({
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }) | (string | ({
        path: string;
    } & {
        format?: string | undefined;
        renderMode?: "local" | "docker" | undefined;
        preflight?: "press-ready" | "press-ready-local" | undefined;
        preflightOption?: string[] | undefined;
    }))[] | undefined;
    title?: string | undefined;
    theme?: string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }) | (string | ({
        specifier: string;
    } & {
        import?: string | string[] | undefined;
    }))[] | undefined;
    cover?: string | ({
        src: string;
    } & {
        htmlPath?: string | boolean | undefined;
        name?: string | undefined;
    }) | undefined;
    author?: string | undefined;
    entryContext?: string | undefined;
    workspaceDir?: string | undefined;
    includeAssets?: string | string[] | undefined;
    copyAsset?: {
        includes?: string[] | undefined;
        excludes?: string[] | undefined;
        includeFileExtensions?: string[] | undefined;
        excludeFileExtensions?: string[] | undefined;
    } | undefined;
    size?: string | undefined;
    pressReady?: boolean | undefined;
    language?: string | undefined;
    readingProgression?: "ltr" | "rtl" | undefined;
    toc?: string | boolean | {
        title?: string | undefined;
        htmlPath?: string | undefined;
        sectionDepth?: number | undefined;
        transformDocumentList?: ((nodeList: StructuredDocument[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
        transformSectionList?: ((nodeList: StructuredDocumentSection[]) => (propsList: {
            children: any;
        }[]) => any) | undefined;
    } | undefined;
    tocTitle?: string | undefined;
    timeout?: number | undefined;
    documentProcessor?: ((option: StringifyMarkdownOptions, metadata: Metadata) => Processor) | undefined;
    vfm?: ({
        title?: string | undefined;
        replace?: ({
            match: (result: RegExpMatchArray, h: any) => Object | string;
            test: RegExp;
        } & {
            [key: string]: unknown;
        })[] | undefined;
        language?: string | undefined;
        style?: string | string[] | undefined;
        partial?: boolean | undefined;
        hardLineBreaks?: boolean | undefined;
        disableFormatHtml?: boolean | undefined;
        math?: boolean | undefined;
    } & {
        [key: string]: unknown;
    }) | undefined;
    image?: string | undefined;
    http?: boolean | undefined;
    viewer?: string | undefined;
    viewerParam?: string | undefined;
    browser?: "chromium" | "firefox" | "webkit" | undefined;
})[], "VivliostyleConfigSchema">]>;
/**
 * @see https://github.com/vivliostyle/vivliostyle-cli/blob/main/docs/config.md
 */
export type VivliostyleConfigSchema = v.InferInput<typeof VivliostyleConfigSchema>;
//# sourceMappingURL=schema.d.ts.map