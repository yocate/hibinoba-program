import http from 'node:http';
import { fileURLToPath, pathToFileURL, URL } from 'node:url';
import handler from 'serve-handler';
import upath from 'upath';
import { viewerRoot } from './const.js';
import { beforeExitHandlers, debug, findAvailablePort, isUrlString, } from './util.js';
let _viewerServer;
let _sourceServer;
export async function prepareServer(option) {
    const viewerUrl = await (option.viewer && isUrlString(option.viewer)
        ? new URL(option.viewer)
        : option.httpServer
            ? (async () => {
                _viewerServer = _viewerServer || (await launchServer(viewerRoot));
                const viewerUrl = new URL('http://localhost');
                viewerUrl.port = `${_viewerServer.port}`;
                viewerUrl.pathname = '/lib/index.html';
                return viewerUrl;
            })()
            : (() => {
                const viewerUrl = new URL('file://');
                viewerUrl.pathname = upath.join(viewerRoot, 'lib/index.html');
                return viewerUrl;
            })());
    const inputUrl = isUrlString(option.input)
        ? new URL(option.input)
        : pathToFileURL(option.input);
    const sourceUrl = await (async () => {
        if (inputUrl.protocol === 'file:' &&
            (option.httpServer ||
                // Use http server because http viewer cannot access to file protocol
                (option.viewer && /^https?:/i.test(option.viewer)))) {
            _sourceServer =
                _sourceServer || (await launchServer(option.workspaceDir));
            const sourceUrl = new URL('http://localhost');
            sourceUrl.port = `${_sourceServer.port}`;
            sourceUrl.pathname = upath.relative(option.workspaceDir, fileURLToPath(inputUrl));
            return sourceUrl;
        }
        return inputUrl;
    })();
    return {
        viewerFullUrl: getViewerFullUrl(option, {
            viewerUrl,
            sourceUrl,
        }),
    };
}
export function teardownServer() {
    if (_viewerServer) {
        _viewerServer.server.close();
        _viewerServer = undefined;
    }
    if (_sourceServer) {
        _sourceServer.server.close();
        _sourceServer = undefined;
    }
}
export function getViewerFullUrl({ size, cropMarks, bleed, cropOffset, css, style, userStyle, singleDoc, quick, viewerParam, }, { viewerUrl, sourceUrl }) {
    const pageSizeValue = size && ('format' in size ? size.format : `${size.width} ${size.height}`);
    function escapeParam(url) {
        return url.replace(/&/g, '%26');
    }
    let viewerParams = sourceUrl.href === 'data:,'
        ? '' // open Viewer start page
        : `src=${escapeParam(sourceUrl.href)}`;
    viewerParams += `&bookMode=${!singleDoc}&renderAllPages=${!quick}`;
    if (style) {
        viewerParams += `&style=${escapeParam(style)}`;
    }
    if (userStyle) {
        viewerParams += `&userStyle=${escapeParam(userStyle)}`;
    }
    if (pageSizeValue || cropMarks || bleed || cropOffset || css) {
        let pageStyle = '@page{';
        if (pageSizeValue) {
            pageStyle += `size:${pageSizeValue};`;
        }
        if (cropMarks) {
            pageStyle += `marks:crop cross;`;
        }
        if (bleed || cropMarks) {
            pageStyle += `bleed:${bleed ?? '3mm'};`;
        }
        if (cropOffset) {
            pageStyle += `crop-offset:${cropOffset};`;
        }
        pageStyle += '}';
        // The pageStyle settings are put between the `/*<viewer>*/` and `/*</viewer>*/`
        // in the `&style=data:,â€¦` viewer parameter so that they are reflected in the
        // Settings menu of the Viewer. Also the custom CSS code is appended after the
        // `/*</viewer>*/` so that it is shown in the Edit CSS box in the Settings menu.
        viewerParams += `&style=data:,/*<viewer>*/${encodeURIComponent(pageStyle)}/*</viewer>*/${encodeURIComponent(css ?? '')}`;
    }
    if (viewerParam) {
        // append additional viewer parameters
        viewerParams += `&${viewerParam}`;
    }
    return `${viewerUrl.href}#${viewerParams}`;
}
function startEndpoint(root) {
    const serve = (req, res) => handler(req, res, {
        public: root,
        cleanUrls: false,
        directoryListing: false,
        headers: [
            {
                source: '**',
                headers: [
                    {
                        key: 'access-control-allow-headers',
                        value: 'Origin, X-Requested-With, Content-Type, Accept, Range',
                    },
                    {
                        key: 'access-control-allow-origin',
                        value: '*',
                    },
                    {
                        key: 'cache-control',
                        value: 'no-cache, no-store, must-revalidate',
                    },
                ],
            },
        ],
    });
    return http.createServer(serve);
}
async function launchServer(root) {
    const port = await findAvailablePort();
    debug(`Launching server... root: ${root} port: ${port}`);
    const server = startEndpoint(root);
    return await new Promise((resolve) => {
        server.listen(port, 'localhost', () => {
            beforeExitHandlers.push(() => {
                server.close();
            });
            resolve({ server, port });
        });
    });
}
//# sourceMappingURL=server.js.map