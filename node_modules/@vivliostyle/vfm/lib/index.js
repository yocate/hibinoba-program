"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringify = exports.VFM = void 0;
var rehype_format_1 = __importDefault(require("rehype-format"));
var rehype_stringify_1 = __importDefault(require("rehype-stringify"));
var unified_1 = __importDefault(require("unified"));
var document_1 = require("./plugins/document");
var math_1 = require("./plugins/math");
var metadata_1 = require("./plugins/metadata");
var replace_1 = require("./plugins/replace");
var revive_parse_1 = require("./revive-parse");
var revive_rehype_1 = require("./revive-rehype");
var utils_1 = require("./utils");
// Expose metadata reading by VFM
__exportStar(require("./plugins/metadata"), exports);
/**
 * Check and update metadata with options.
 * @param metadata Metadata.
 * @param options Options.
 */
var checkMetadata = function (metadata, options) {
    if (metadata.title === undefined && options.title !== undefined) {
        metadata.title = options.title;
    }
    if (metadata.lang === undefined && options.language !== undefined) {
        metadata.lang = options.language;
    }
    if (options.style) {
        if (metadata.link === undefined) {
            metadata.link = [];
        }
        if (typeof options.style === 'string') {
            metadata.link.push([
                { name: 'rel', value: 'stylesheet' },
                { name: 'type', value: 'text/css' },
                { name: 'href', value: options.style },
            ]);
        }
        else if (Array.isArray(options.style)) {
            for (var _i = 0, _a = options.style; _i < _a.length; _i++) {
                var style = _a[_i];
                metadata.link.push([
                    { name: 'rel', value: 'stylesheet' },
                    { name: 'type', value: 'text/css' },
                    { name: 'href', value: style },
                ]);
            }
        }
    }
};
/**
 * Create Unified processor for Markdown AST and Hypertext AST.
 * @param options Options.
 * @returns Unified processor.
 */
function VFM(_a, metadata) {
    var _b = _a === void 0 ? {} : _a, _c = _b.style, style = _c === void 0 ? undefined : _c, _d = _b.partial, partial = _d === void 0 ? false : _d, _e = _b.title, title = _e === void 0 ? undefined : _e, _f = _b.language, language = _f === void 0 ? undefined : _f, _g = _b.replace, replace = _g === void 0 ? undefined : _g, _h = _b.hardLineBreaks, hardLineBreaks = _h === void 0 ? false : _h, _j = _b.disableFormatHtml, disableFormatHtml = _j === void 0 ? false : _j, _k = _b.math, math = _k === void 0 ? true : _k;
    if (metadata === void 0) { metadata = {}; }
    checkMetadata(metadata, { style: style, title: title, language: language });
    // Prioritize metadata `vfm` settings over options
    if (metadata.vfm) {
        if (metadata.vfm.math !== undefined) {
            math = metadata.vfm.math;
        }
        if (metadata.vfm.partial !== undefined) {
            partial = metadata.vfm.partial;
        }
        if (metadata.vfm.hardLineBreaks !== undefined) {
            hardLineBreaks = metadata.vfm.hardLineBreaks;
        }
        if (metadata.vfm.disableFormatHtml !== undefined) {
            disableFormatHtml = metadata.vfm.disableFormatHtml;
        }
    }
    var processor = (0, unified_1.default)()
        .use((0, revive_parse_1.reviveParse)(hardLineBreaks, math))
        .data('settings', { position: true })
        .use(revive_rehype_1.reviveRehype);
    if (replace) {
        processor.use(replace_1.replace, { rules: replace });
    }
    if (!partial) {
        processor.use(document_1.mdast, metadata);
    }
    processor.use(rehype_stringify_1.default);
    // Must be run after `rehype-document` to write to `<head>`
    if (math) {
        processor.use(math_1.hast);
    }
    // Explicitly specify true if want unformatted HTML during development or debug
    if (!disableFormatHtml) {
        processor.use(rehype_format_1.default);
    }
    return processor;
}
exports.VFM = VFM;
/**
 * Convert markdown to a stringify (HTML).
 * @param markdownString Markdown string.
 * @param options Options.
 * @returns HTML string.
 */
function stringify(markdownString, options, metadata) {
    if (options === void 0) { options = {}; }
    if (metadata === void 0) { metadata = (0, metadata_1.readMetadata)(markdownString); }
    var processor = VFM(options, metadata);
    var vfile = processor.processSync(markdownString);
    (0, utils_1.debug)(vfile.data);
    return String(vfile);
}
exports.stringify = stringify;
