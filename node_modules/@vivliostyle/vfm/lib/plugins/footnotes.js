"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hast = exports.mdast = void 0;
var hast_util_select_1 = require("hast-util-select");
var remark_footnotes_1 = __importDefault(require("remark-footnotes"));
/**
 * Replace the footnote link with Pandoc format.
 * @param tree Tree of Hypertext AST.
 */
var replaceFootnoteLinks = function (tree) {
    var sups = (0, hast_util_select_1.selectAll)('sup[id^="fnref-"]', tree).filter(function (node) { return node.children.length === 1 && node.children[0].tagName === 'a'; });
    for (var i = 0; i < sups.length; ++i) {
        var parent_1 = sups[i];
        var refIndex = i + 1;
        parent_1.tagName = 'a';
        parent_1.properties = {
            id: "fnref".concat(refIndex),
            href: "#fn".concat(refIndex),
            className: ['footnote-ref'],
            role: 'doc-noteref',
        };
        var child = parent_1.children[0];
        child.tagName = 'sup';
        child.properties = {};
        child.children = [{ type: 'text', value: "".concat(refIndex) }];
    }
};
/**
 * Check if it has a class name as a back reference.
 * @param className Array of class names.
 * @returns `true` for back reference, `false` otherwise.
 */
var hasBackReferenceClass = function (className) {
    if (Array.isArray(className)) {
        for (var _i = 0, className_1 = className; _i < className_1.length; _i++) {
            var name_1 = className_1[_i];
            if (name_1 === 'footnote-backref') {
                return true;
            }
        }
    }
    return false;
};
/**
 * Replace back reference with Pandoc format.
 * @param elements Children elements of footnote.
 * @param index Index of footnote.
 */
var replaceBackReference = function (elements, index) {
    for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
        var element = elements_1[_i];
        if (element.type === 'element' &&
            element.tagName === 'a' &&
            element.properties &&
            hasBackReferenceClass(element.properties.className)) {
            element.properties.href = "#fnref".concat(index);
            element.properties.className = ['footnote-back'];
            element.properties.role = 'doc-backlink';
            // Back reference is only one
            break;
        }
    }
};
/**
 * Replace the footnote with Pandoc format.
 * @param tree Tree of Hypertext AST.
 */
var replaceFootnotes = function (tree) {
    var area = (0, hast_util_select_1.select)('div.footnotes', tree);
    if (area && area.properties) {
        area.tagName = 'section';
        area.properties.role = 'doc-endnotes';
    }
    else {
        return;
    }
    var items = (0, hast_util_select_1.selectAll)('section.footnotes ol li', tree);
    for (var i = 0; i < items.length; ++i) {
        var item = items[i];
        if (!item.properties) {
            continue;
        }
        var refIndex = i + 1;
        item.properties.id = "fn".concat(refIndex);
        item.properties.role = 'doc-endnote';
        replaceBackReference(item.children, refIndex);
    }
};
/**
 * Process Markdown AST.
 */
exports.mdast = [remark_footnotes_1.default, { inlineNotes: true }];
/**
 * Process math related Hypertext AST.
 * Resolves HTML diffs between `remark-footnotes` and Pandoc footnotes.
 */
var hast = function () { return function (tree) {
    replaceFootnoteLinks(tree);
    replaceFootnotes(tree);
}; };
exports.hast = hast;
