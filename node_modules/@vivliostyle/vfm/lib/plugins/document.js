"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mdast = void 0;
var doctype_1 = __importDefault(require("doctype"));
var hastscript_1 = __importDefault(require("hastscript"));
/**
 * Create AST properties from attributes.
 * @param attributes Attributes.
 * @returns Properties.
 */
var createProperties = function (attributes) {
    if (!attributes) {
        return {};
    }
    var props = {};
    for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
        var attr = attributes_1[_i];
        props[attr.name] = attr.value;
    }
    return props;
};
/**
 * Create Markdown AST for `<head>`.
 * @param data Metadata.
 * @param vfile VFile.
 * @returns AST of `<head>`.
 */
var createHead = function (data, vfile) {
    var head = [{ type: 'text', value: '\n' }, (0, hastscript_1.default)('meta', { charset: 'utf-8' })];
    // <title>...</title>
    {
        var title = typeof data.title === 'string' ? data.title : vfile.stem;
        if (typeof title === 'string') {
            head.push({ type: 'text', value: '\n' }, (0, hastscript_1.default)('title', [title]));
        }
    }
    // <base>
    if (data.base) {
        var props = createProperties(data.base);
        head.push({ type: 'text', value: '\n' }, (0, hastscript_1.default)('base', props));
    }
    // <meta>
    {
        // Add viewport of default
        var meta = data.meta ? __spreadArray([], data.meta, true) : [];
        meta.unshift([
            { name: 'name', value: 'viewport' },
            { name: 'content', value: 'width=device-width, initial-scale=1' },
        ]);
        for (var _i = 0, meta_1 = meta; _i < meta_1.length; _i++) {
            var attributes = meta_1[_i];
            var props = createProperties(attributes);
            head.push({ type: 'text', value: '\n' }, (0, hastscript_1.default)('meta', props));
        }
        head.push({ type: 'text', value: '\n' });
    }
    // <link>
    if (data.link) {
        for (var _a = 0, _b = data.link; _a < _b.length; _a++) {
            var attributes = _b[_a];
            var props = createProperties(attributes);
            head.push({ type: 'text', value: '\n' }, (0, hastscript_1.default)('link', props));
        }
        head.push({ type: 'text', value: '\n' });
    }
    // <script>
    if (data.script) {
        for (var _c = 0, _d = data.script; _c < _d.length; _c++) {
            var attributes = _d[_c];
            var props = createProperties(attributes);
            head.push({ type: 'text', value: '\n' }, (0, hastscript_1.default)('script', props));
        }
        head.push({ type: 'text', value: '\n' });
    }
    return head;
};
/**
 * Create Markdown AST for `<body>`.
 * @param metadata Metadata.
 * @param tree Tree of Markdown AST.
 * @returns AST of `<body>`.
 */
var createBody = function (metadata, tree) {
    // <body>...</body>
    var contents = tree.type === 'root' && Array.isArray(tree.children)
        ? tree.children.concat()
        : [tree];
    if (0 < contents.length) {
        contents.unshift({ type: 'text', value: '\n' });
    }
    contents.push({ type: 'text', value: '\n' });
    var props = createProperties(metadata.body);
    // <body class="root-class body-class1 body-class2 ...">
    if (typeof metadata.class === 'string') {
        props.class = props.class
            ? "".concat(metadata.class, " ").concat(props.class)
            : metadata.class;
    }
    return (0, hastscript_1.default)('body', props, contents);
};
/**
 * Create properties for `<html>`.
 * Sets the value defined for `html` in Frontmatter.
 * However, if `id`,` lang`, `dir`, and `class` are defined in the root, those are given priority.
 * @param metadata Metadata.
 * @param tree Tree of Markdown AST.
 * @param vfile VFile.
 * @returns AST of `<html>`.
 */
var createHTML = function (metadata, tree, vfile) {
    var props = createProperties(metadata.html);
    if (typeof metadata.id === 'string') {
        props.id = metadata.id;
    }
    if (typeof metadata.lang === 'string') {
        props.lang = metadata.lang;
    }
    if (typeof metadata.dir === 'string') {
        props.dir = metadata.dir;
    }
    // <html class="root-class html-class1 html-class2 ...">
    if (typeof metadata.class === 'string') {
        props.class = props.class
            ? "".concat(metadata.class, " ").concat(props.class)
            : metadata.class;
    }
    return (0, hastscript_1.default)('html', props, [
        { type: 'text', value: '\n' },
        (0, hastscript_1.default)('head', createHead(metadata, vfile)),
        { type: 'text', value: '\n' },
        createBody(metadata, tree),
        { type: 'text', value: '\n' },
    ]);
};
/**
 * Process Markdown AST.
 * @param data Options.
 * @returns Transformer.
 */
var mdast = function (data) { return function (tree, vfile) {
    return {
        type: 'root',
        children: [
            { type: 'doctype', name: (0, doctype_1.default)(5) },
            { type: 'text', value: '\n' },
            createHTML(data, tree, vfile),
            { type: 'text', value: '\n' },
        ],
    };
}; };
exports.mdast = mdast;
