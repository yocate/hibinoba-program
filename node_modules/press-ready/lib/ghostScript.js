"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ghostScript = exports.isGhostscriptAvailable = void 0;
const fs_1 = __importDefault(require("fs"));
const upath_1 = __importDefault(require("upath"));
const execa_1 = __importDefault(require("execa"));
const os_1 = require("os");
const upath_2 = require("upath");
const mustache_1 = __importDefault(require("mustache"));
const uuid_1 = require("uuid");
const shelljs_1 = __importDefault(require("shelljs"));
const debug = require('debug')('press-ready');
const ASSETS_DIR = upath_1.default.resolve(__dirname, '..', 'assets');
function isGhostscriptAvailable() {
    return ((process.platform === 'win32' &&
        (shelljs_1.default.which('gswin64c') || shelljs_1.default.which('gswin32c'))) ||
        shelljs_1.default.which('gs'));
}
exports.isGhostscriptAvailable = isGhostscriptAvailable;
async function ghostScript({ inputPath, outputPath, pdfxDefTemplatePath = upath_1.default.join(ASSETS_DIR, 'PDFX_def.ps.mustache'), sourceIccProfilePath = upath_1.default.join(ASSETS_DIR, 'JapanColor2001Coated.icc'), grayScale = false, enforceOutline = false, boundaryBoxes = false, title = 'Auto-generated PDF (press-ready)', }) {
    const workingDir = os_1.tmpdir();
    const id = uuid_1.v4();
    // ICC profile
    const iccProfilePath = upath_2.join(workingDir, `press-ready-${id}.icc`);
    fs_1.default.copyFileSync(sourceIccProfilePath, iccProfilePath);
    // PDFXDef
    const pdfxDefPath = upath_2.join(workingDir, `press-ready-${id}.ps`);
    const pdfxDefTemplateString = fs_1.default.readFileSync(pdfxDefTemplatePath, 'utf-8');
    const pdfxDef = mustache_1.default.render(pdfxDefTemplateString, {
        title,
        iccProfilePath,
    });
    fs_1.default.writeFileSync(pdfxDefPath, pdfxDef, 'utf-8');
    // configure gs command
    const gsCommand = (process.platform === 'win32' &&
        ((shelljs_1.default.which('gswin64c') && 'gswin64c') ||
            (shelljs_1.default.which('gswin32c') && 'gswin32c'))) ||
        'gs';
    const gsOptions = [
        '-dPDFX',
        '-dBATCH',
        '-dNOPAUSE',
        '-dNOOUTERSAVE',
        '-sDEVICE=pdfwrite',
        '-dPDFSTOPONERROR',
        '-dShowAnnots=false',
        '-dPDFSETTINGS=/prepress',
        '-dPrinted',
        '-r600',
        '-dGrayImageResolution=600',
        '-dMonoImageResolution=600',
        '-dColorImageResolution=600',
        `-sOutputFile=${outputPath}`,
    ];
    if (boundaryBoxes) {
        gsOptions.push('-dUseCropBox', '-dUseTrimBox', '-dUseBleedBox');
    }
    if (enforceOutline) {
        gsOptions.push('-dNoOutputFonts');
    }
    if (grayScale) {
        gsOptions.push('-sProcessColorModel=DeviceGray', '-sColorConversionStrategy=Gray', '-sColorConversionStrategyForImages=Gray');
    }
    else {
        gsOptions.push('-sProcessColorModel=DeviceCMYK', '-sColorConversionStrategy=CMYK', '-sColorConversionStrategyForImages=CMYK', '-dOverrideICC', `-sOutputICCProfile=${iccProfilePath}`);
    }
    const args = [...gsOptions, pdfxDefPath, inputPath];
    const command = [gsCommand, args];
    debug(gsCommand, args.join(' '));
    try {
        // generate pdf with ghostscript
        const { stdout, stderr } = await execa_1.default(...command);
        return {
            command,
            rawOutput: stdout,
            rawError: stderr,
        };
    }
    catch (err) {
        return {
            command,
            rawOutput: err.stdout,
            rawError: err.stderr,
        };
    }
    finally {
        fs_1.default.unlinkSync(iccProfilePath);
        fs_1.default.unlinkSync(pdfxDefPath);
    }
}
exports.ghostScript = ghostScript;
