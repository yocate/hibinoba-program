"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.inspectPDF = void 0;
const chalk_1 = __importDefault(require("chalk"));
const cli_table_1 = __importDefault(require("cli-table"));
const pdffonts_1 = require("./pdffonts");
const util_1 = require("./util");
const table_1 = require("./table");
const debug = require('debug')('press-ready');
async function inspectPDF(filePath) {
    const { fonts } = await pdffonts_1.pdfFonts(filePath);
    if (fonts.length) {
        const table = new cli_table_1.default({
            head: ['name', 'type', 'embedded', 'subset'],
            ...table_1.tableArgs,
        });
        for (const font of fonts) {
            table.push([
                chalk_1.default.gray(font.name),
                chalk_1.default.yellow(font.type),
                font.emb === 'yes' ? chalk_1.default.green('yes') : chalk_1.default.red('no'),
                font.sub === 'yes' ? chalk_1.default.green('yes') : chalk_1.default.red('no'),
            ]);
        }
        util_1.rawLog(table.toString());
    }
    else {
        util_1.log(chalk_1.default.yellow('No fonts found'));
    }
    debug(fonts);
    // Check if all fonts are embedded
    const isEmbedded = fonts.every((font) => font.emb === 'yes');
    // Check if all fonts are a subset of font
    const isSubset = fonts.every((font) => font.sub === 'yes');
    // const shouldEnforceOutline = !isEmbedded || !isSubset;
    const shouldEnforceOutline = fonts.some((font) => font.type === 'Type 3');
    if (shouldEnforceOutline) {
        util_1.log(chalk_1.default.red('Some fonts need to be outlined'));
    }
    else {
        util_1.log(chalk_1.default.green('Every font is properly embedded'));
    }
    return {
        isEmbedded,
        isSubset,
        shouldEnforceOutline,
    };
}
exports.inspectPDF = inspectPDF;
